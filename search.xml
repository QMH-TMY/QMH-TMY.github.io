<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>5G之后是6G？</title>
      <link href="/title/fb817f20/"/>
      <url>/title/fb817f20/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/10/31/KooVW4.jpg" alt="5gON"><br><a id="more"></a></p><h2 id="5G商用"><a href="#5G商用" class="headerlink" title="5G商用"></a>5G商用</h2><p>今天上午，2019中国国际信息通信展在北京国家会议中心召开。在5G商用启动仪式上，工信部与中国移动、中国联通、中国电信、中国铁塔共同宣布5G正式商用。11月1日，也即明天，各地的5G套餐就可以办理了。对于大部分消费者来说，有尝鲜的意愿，但目前价格还比较贵，真正办理的估计不多。但不管贵不贵，速度快倒是真的。</p><h2 id="运营商的新玩法"><a href="#运营商的新玩法" class="headerlink" title="运营商的新玩法"></a>运营商的新玩法</h2><p>5G和4G相比，有了很多不同的情况，尤其是在运营商层面。4G时代各大运营商相互竞争，5G时代，运营商得抱团取暖，合作共赢。上面已经表明，电信和联通要共同建设通信基站，以往各自建塔的模式玩不转了，唯一能独立搞的就只有移动。5G，使用的波更短，意味着要使用更多的基站，而每个基站都挺贵的，所以总体基站建设费用会比较高，从目前公布的基础套餐价最低为128也能看出这点。据最新数据估计，5G基站建设得分好几年，总投资费用高达数万亿。</p><p>从频段的分配上也能看出，这两家拿到的5G频段加起来还没人家移动一家多，唯一的好处是，连通电信的频段处于最成熟的区间，布置网络要容易些。</p><table><thead><tr><th style="text-align:center">移动</th><th style="text-align:center">联通</th><th style="text-align:center">电信 </th></tr></thead><tbody><tr><td style="text-align:center">260MHz</td><td style="text-align:center">100MHz</td><td style="text-align:center">100MHz</td></tr></tbody></table><p>时代变了，以前的冤家，现在成了亲家，仇人成友人。联通和电信多年发展的失利致使移动独大，只好两家合纵连横同移动拼，真真是有点儿三国演义的味道，然而现实是深刻的，利益是重要的，脸面是可以不要的，所以两家得合作。</p><p><img src="https://s2.ax1x.com/2019/10/31/Kooml9.md.jpg" alt="TelUni"></p><p>除此之外，运营商和用户在基站的问题上还存在一个博弈过程。用户的要求是，基站不能放我家旁，但信号必需好，放在别人家旁我没意见。所以逼着运营耍手段，给基站来个大隐身。路边的井盖，路灯，房顶的空调机，绿化树，排气管等等全都成为了基站的新替身。城市人从来看不到基站，但它们却一直在你身边。</p><p><img src="https://s2.ax1x.com/2019/11/01/KTx8jf.jpg" alt="basestation1"></p><p>你以为是绿化，其实是基站。</p><p><img src="https://s2.ax1x.com/2019/11/01/KTxTKK.jpg" alt="basestation2"></p><p>你以为是热水器，其实是基站。</p><p><img src="https://s2.ax1x.com/2019/11/01/KTxx2t.jpg" alt="basestation3"></p><p>请勿践踏花草，其实里面也是基站，一体两用。</p><p>5G基站大幅度增加，耗资巨大，必然导致有的地方投资薄弱，很多地方未来几年都将没有5G信号，所以买5G手机先确认自家信号，别买了用不了。下表中的城市是首批开通5G的城市，其他城市可能要等两年左右。</p><table><thead><tr><th style="text-align:center">直辖市</th><th style="text-align:center">省会城市   </th></tr></thead><tbody><tr><td style="text-align:center">北京，上海</td><td style="text-align:center">成都，杭州</td></tr><tr><td style="text-align:center">天津，重庆</td><td style="text-align:center">南京，武汉等</td></tr></tbody></table><table><thead><tr><th style="text-align:center">单列市</th><th style="text-align:center">重要城市</th></tr></thead><tbody><tr><td style="text-align:center">深圳，青岛</td><td style="text-align:center">雄安，苏州 </td></tr><tr><td style="text-align:center">宁波，厦门</td><td style="text-align:center">温州，张家口</td></tr><tr><td style="text-align:center">大连</td><td style="text-align:center"></td></tr></tbody></table><p>我在想，要是5G时代，联通和电信合起来还干不过移动，是不是意味着权力的洗牌，会不会拆分一家合并到另外两家中去？运营商的套路是丰富多样的，不知未来的套餐又会出什么新花样，反正消费者要看清楚，别被忽悠。</p><h2 id="5G应用场景猜测"><a href="#5G应用场景猜测" class="headerlink" title="5G应用场景猜测"></a>5G应用场景猜测</h2><p>前段时间在B站上，北京邮电大学的何同学试用了5G，并就未来的应用做了讨论。他借鉴了4G刚出来时人们的反应，表明预测未来的应用确实是挺难的。<a href="https://www.bilibili.com/video/av54737593" target="_blank" rel="noopener">视频：5G有什么用</a></p><p>尽管很难预测，但我还是大胆猜猜5G的应用。  </p><table><thead><tr><th style="text-align:center">预</th><th style="text-align:center">测  </th></tr></thead><tbody><tr><td style="text-align:center">远程医疗</td><td style="text-align:center">智慧施政   </td></tr><tr><td style="text-align:center">智能家具</td><td style="text-align:center">工业物联  </td></tr></tbody></table><p>远程医疗：一是指优秀的专家可以远程做手术，节约时间和交通成本。二指医生可以通过网络对家里的病人进行指导和开展医疗服务。4G让人吃饭不出家，点外卖；5G就让人生病不出家，点医生，点药。未来的医生可能会享受很高的社会地位，他们通过提供更好的服务，赚取高额的佣金。同时，这种新的医患关系避免物理接触，保护了医生。</p><p>智慧施政：民智越开，则政府越弱，一旦老百姓掌握了信息，那么政府的很多服务可以取消，政府不能随便制定政策，很多政府服务要交给智慧系统，很多政府职权要还给百姓。</p><p>智能家具：物联网时代，硬件大爆发，未来的家庭，联网的器件增多，冰箱，空调，桌子，椅子可能都有某种程度的网络功能，并提供相应的服务。</p><p>工业物联：打造全新的制造链和运输链，智能驾驶，智能运输系统，同时可能出现新的产业联盟，类似今天存在的各种协会。</p><h2 id="5G中的Polar码"><a href="#5G中的Polar码" class="headerlink" title="5G中的Polar码"></a>5G中的Polar码</h2><p>Polar码是5G中的一种编码技术，属于5G核心技术。Polar码源于2008年的一篇论文Channel Polarization。作者是土耳其科学家埃达尔·阿勒坎（Erdal Arikan）。1981年，阿勒坎在位于加州理工学院获得本科学位，随后他去了美国的另一所名校——麻省理工学院，于1985年得到电子信息工程专业的博士学位。阿勒坎的博士生导师是美国人罗伯特·加拉格（Robert Gallager）教授，而加拉格的导师，也就是阿勒坎的师爷，则是大名鼎鼎的信息论鼻祖香农。原本以为只是个牛叉人物，没想到竟然是香农大佬门徒。不过想来也对，不是这个领域的人，又如何搞出这些编码呢？</p><p>华为公司在论文出来后，就调集人手攻克论文提出的编码，并最终得以攻克。前几年，华为推动的Polar码在3GPP会议上同LDPC码共同确立为5G技术，LDPC管数据信道，Polar码则控制通信信道。Polar码中，重要的是一个矩阵问题，解决了矩阵问题，编码问题就解决了。当然，我不是专家，不太懂，无法发表更多看法。</p><p>值得一提的是，美国人推动的LDPC就是阿勒坎的师傅加拉格搞出来的，最终两师徒的理论均成为5G核心技术，美国选了师傅，中国选了徒弟，然后相互竞争，相互斗。</p><p><img src="https://s2.ax1x.com/2019/10/31/Koo3FO.png" alt="Edel"></p><p>图为华为创始人任正非为阿勒坎颁奖，感谢其在该领域的杰出贡献</p><p>除了编码，5G中还有其他的核心技术，包括OFDM（正交频分复用），MIMO（多天线），新的组网结构。在Erik Dahlman的《5G NR》一书提到 “Both LTE and NR are developed by 3GPP and hence have a common background and share several technology components. Many of the design choices in NR are also based on experience from LTE. Furthermore, LTE continues to evolve in parallel with NR and is an important component in 5G radio access.” 可见，4G (LTE)中有些技术是用到5G里面的，自然5G和4G是兼容的。</p><h2 id="6G研究"><a href="#6G研究" class="headerlink" title="6G研究"></a>6G研究</h2><p>2018年两会期间，工信部部长苗圩表示，中国已开展6G的研发，预计2030年试使用。中国通信产业要做到，用一代，产一代，研一代。</p><p><img src="https://s2.ax1x.com/2019/10/31/KoTC1H.jpg" alt="miaoyu"></p><p>图为工信部长苗圩接受记者访问，并透露6G研究情况</p><p>目前的5G，仍然有缺点，很多缺点就是4G(LTE)自带的，在5G仍然没有解决，所以6G要首先解决这些问题，不然下一代通信技术不可能得到发展。5G都这么快了，6G又该如何？这种问题，想象力不够，水平不够，想不出来。但从社会生产力变革的发展和国家对通信行业的投入来看，未来搞通信的人还将大有作为。这个产业涉及的硬件如芯片，天线，软件如算法，智能调度等将得到进一步发展。当然，6G现在开在概念期，华为也刚开始投入研究，社会上谈得不多。</p><p>我个人看好6G，换句话说，我认为未来从事计算机，通信，算法，芯片，天线等行业的人将大有可为。知道了这些，怎么选路就很清楚了。人一辈子能碰上一个技术浪潮，加之努力，就可能过得很好，何况处在人类技术大爆发的年代，新技术正不断冒出，新思想正时刻迸发。人人都讲抓住机遇，但机遇也要靠自己奋斗，不是喊喊口号就行。新的技术会催生新的公司，同时灭掉旧的公司。今天的淘宝，腾讯，谁说未来不会成为下一个诺基亚？对于自身来讲，个人的人生道路就看他处在历史的潮流中是抱残守缺还是革故鼎新。</p><h2 id="G"><a href="#G" class="headerlink" title="?G"></a>?G</h2><p>现在再进一步思考：6G过后呢？难道7G？可是信道容量是有极限的，香农定理早已经证明了这一点。<br>$$ C= Blog_{2}(1 + \frac{S}{N}), (N =n_0B)  $$<br>若上面的香农公式中，B趋于无穷，则在给定$S/n_0$的情况下，C最大只能等于<br>$$1.44\frac{S}{n_0}$$ </p><p>所以6G过后，是无G。没有了，等待新技术的突破吧，尤其是物理突破。没有物理理论上的突破，人类的技术就不会进步。实际上，每一次物理的突破都带来了技术的革新。我们回顾自1905年相对论诞生以来的一百多年，原子弹，核电站，GPS成为现在时态；量子力学的诞生提出了晶格理论，催生了新材料合成技术，进而推动半导体发展，集成电路发展，最后是建立于之上的计算机，互联网，一直到今天我们都还在吃量子力学的老本儿。最近一段时间，谷歌的<a href="https://www.nature.com/articles/s41586-019-1666-5" target="_blank" rel="noopener">量子霸权</a>不也再次挑动人们的眼球吗？</p><p>当然，有人说，难道不能突破香农定律吗？还别说，还真有这种人，而且还写了相应的文章，只是没有哪位审稿人给通过。另外，芯片行业的摩尔定律也到头了，CPU能做到1nm吗？能再小吗？不行了，因为电子有大小的，一到电子这个尺度，就要考虑量子效应。</p><p>所以，物理上如果不能取得新突破，则人类就会像欧洲中世纪一样，长时间生活在技术停滞发展的社会。想象如果50年后人们还在玩视频直播，还过着2019年的生活，这会不会出问题？相反，新理论会催生新的生产力，进而产生新的技术并推动文明的前进。今天的地球，斗争处于文明体之间，进步的活下来，落后的要么灭亡，要么遭奴役。这个时代是和科技战车绑架在一起的时代，任何人都只能支持科技的发展。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] 文明的冲突，[美]亨廷顿<br>[2] 5G核心技术，Qualcomm(高通)中国<br>[3] 手机基站天线去哪儿了？知乎老狼<br>[4] 5G NR: The Next Generation Wireless Access Technology<br>[5] Channel Polarization, Erdal Arikan, Senior Member, IEEE.  </p>]]></content>
      
      
      <categories>
          
          <category> 通信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> It </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>资深大牛的博客</title>
      <link href="/title/f2d8edc5/"/>
      <url>/title/f2d8edc5/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/10/30/K5YRsK.jpg" alt="niubility"><br><a id="more"></a></p><h2 id="整理一份行业大牛的博客"><a href="#整理一份行业大牛的博客" class="headerlink" title="整理一份行业大牛的博客"></a>整理一份行业大牛的博客</h2><p>00.<a href="http://www.yinwang.org/" target="_blank" rel="noopener">王垠</a></p><p>01.<a href="https://blog.codingnow.com/" target="_blank" rel="noopener">云风</a></p><p>02.<a href="http://blog.yufeng.info/" target="_blank" rel="noopener">余峰</a></p><p>03.<a href="https://www.cnblogs.com/Solstice/" target="_blank" rel="noopener">陈硕</a></p><p>04.<a href="http://blog.zhaojie.me/" target="_blank" rel="noopener">老赵</a></p><p>05.<a href="https://blog.csdn.net/luoshengyang" target="_blank" rel="noopener">老罗</a></p><p>06.<a href="https://blog.csdn.net/21aspnet" target="_blank" rel="noopener">无界</a></p><p>07.<a href="http://www.ruanyifeng.com/blog/" target="_blank" rel="noopener">阮一峰</a></p><p>08.<a href="http://mindhacks.cn/" target="_blank" rel="noopener">刘未鹏</a></p><p>09.<a href="https://www.trinea.cn/" target="_blank" rel="noopener">吴更新</a></p><p>10.<a href="http://www.cppblog.com/vczh" target="_blank" rel="noopener">VCZh</a></p><p>11.<a href="https://www.byvoid.com/blog" target="_blank" rel="noopener">BYVoid</a></p><p>12.<a href="https://blog.csdn.net/v_july_v" target="_blank" rel="noopener">七月在线创始人</a></p><p>13.<a href="http://www.zhuangbiaowei.com/blog/" target="_blank" rel="noopener">读书，思考，生活</a></p><p>14.<a href="https://www.captainbed.net/troubleshooter/" target="_blank" rel="noopener">床长人工智能教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>双托管代码</title>
      <link href="/title/53e77485/"/>
      <url>/title/53e77485/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/10/30/K5YBa4.md.jpg" alt="dulgit"><br><a id="more"></a></p><hr><h2 id="一：背景"><a href="#一：背景" class="headerlink" title="一：背景"></a>一：背景</h2><p>近期美国加紧封锁大棒，不但对中国，据说连委内瑞纳一个小国也被禁止使用Photoshop。结合前段时间github封禁中东开发者的情况，我认为中国的开发者需要把代码迁移一下，迁移到国内。目前国内的托管平台有多个，腾讯开发者平台，码云，还有最近华为开放的ihub，我选择了码云。</p><hr><h2 id="二：双托管"><a href="#二：双托管" class="headerlink" title="二：双托管"></a>二：双托管</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">首先查看配置.</span><br><span class="line">$git remote -v </span><br><span class="line">origin git@github.com:USERNAME/package.git (fetch)</span><br><span class="line">origin git@github.com:USERNAME/package.git (push)</span><br><span class="line">删除github的配置.</span><br><span class="line">$git remote rm origin</span><br><span class="line">重新添加新配置.</span><br><span class="line">$git remote add github git@github.com:USERNAME/package.git</span><br><span class="line">$git remote add gitee  git@gitee.com:USERNAME1/package1.git</span><br><span class="line">解决推送冲突</span><br><span class="line">$git pull gitee master --allow-unrelated-histories</span><br><span class="line">推送到两个平台</span><br><span class="line">$git push gitee  master </span><br><span class="line">$git push github master</span><br></pre></td></tr></table></figure><p>如果想存放在多个平台，修改同上面一样，只需要加入另一个平台的地址就行。</p><p>目前，国内平台多，但和Github比还有差距，仍需相关方继续推动，促进国内源代码托管。同时做好国际化，鼓励国外工程师托管优质代码到中国的服务器。</p>]]></content>
      
      
      <categories>
          
          <category> 代码托管 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>何以修身？</title>
      <link href="/title/70af6bb7/"/>
      <url>/title/70af6bb7/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/10/30/K5YMqS.jpg" alt="beyourself"><br><a id="more"></a></p><h2 id="保持谦虚"><a href="#保持谦虚" class="headerlink" title="保持谦虚"></a>保持谦虚</h2><p>据我所知，人越是不懂便叫得越厉害，越是懂得多反而谦虚谨慎。人的认知就像一个气球，懂得越多则撑得越大，接触的未知面就越广，所以自然就越谦虚；相反，什么都不懂的人，未知面小了，便以为自己什么都懂了，他们认为，只要没人说自己不懂，自己便全都懂。如此，长傲和多言成了他们的随身法宝。长傲、多言这两个弊病，我自己也经常犯，细细想来，古时世卿大夫的兴与衰，近来官场的祸与福，未尝不是由这两个弊病导致的。</p><p>保持谦虚谨慎实在是人性中的一大亮点，而世人包括我自己在内，又多不谦虚。因为不谦虚，所以便傲起来了。做官的一俟官位稳当，官性就起来了，人性就龟缩了。被人一口一个书记，部长，领导叫着，自己也一步步走入自己挖的坑，跳入权势和名利的争夺圈。须知，权力的本质在于，即使不曾刻意追逐，甚至是被迫拥有，掌权者也会自然而然去追逐更多的权力。因为这样傲起来地快，所以倒下去也便一样地快。由此，身败名裂者，历史上实在为数太多。骄傲起来的，气焰盛了，便觉得自己了不得了，觉得老子天下第一聪明，但这种聪明多的是小聪明，少有大智慧。可是，难道人们就没有反躬自省吗？有的，但人们往往不习惯于理智反省，而习惯于情绪的反省。中文里有个成语叫闭门思过，你说思谁的过？他思别人的过！不用说，我们自己也这么干过。我们和别人出了争端，闹了矛盾时多半是不会反思的，反而是相互指责。我们喜欢用的句式是：他…如何如何，都是他…怎样怎样。一个例子是女人对男人的控诉：他又不爱我了，他又…我了，他总是….。这种甩黑锅的习惯甚至不是人的缺点，而是人的特点。即令监狱里被判刑的囚犯都说自己是被冤枉的，那么作为一个正常人，我们又如何肯轻易认错呢？然而，科技的进步，家庭的和睦，无不有谦虚谨慎的功，也无不表明狂傲，多言的过。事实证明只有修谦虚谨慎的功，才弥补得了狂傲，多言的过。狂傲，多言只会自欺欺人，只会自己给自己洗脑，别人不来骗自己，反而自己要骗自己。</p><p>自己骗自己的范例，股市体现得最为精妙。凡是买股票的，没有不觉自己决策英明的。做多的，总盼着涨，即令下跌，眼随着曲线往下看，但心却依然在往上升。明明跌了，却还要反复骗自己肯定会涨。玩股票讲究两点：一要选得准，二要拿得稳。很多人也知道这两点，但第一点98%的人不知道自己不具备，反而觉得自己全具备。第一点学个半吊子，第二点又死守，学什么却什么都不对，最后只能被割韭菜为人接盘。没有人发现，股票分析师有大机构养着。他们自己可能从不操作股票，反而靠写各种炒股书籍来指挥散户，实际上他们的工作就是忽悠散户。他们不靠买卖股票赚钱，他们靠开讲座，卖书忽悠散户买卖股票挣钱。股市里，大家都说要稳，要谨慎，然而自己骗自己者，少吗？道听途说，盲目自信害着谁，自己遭了才知道。实际上即便遭了，很多人还不知道。狂傲，盲目自大作的祟，即令他们踩最多的坑，倒最大的霉，嘴上却还唱着最美的赞歌。</p><h2 id="读书以明理"><a href="#读书以明理" class="headerlink" title="读书以明理"></a>读书以明理</h2><p>面对我们自己的愚蠢，怎么办？我想，人生路上，还是多读点书为好。肚子饿了，知道吃饭，脑子饿了，精神空虚了，则宜读书。多读一册书，多懂一行。懂得一行就掌握了一个维度；懂得多个领域，就掌握了多个维度。多掌握几个维度，也免得被人忽悠。许多人讲，工作太忙啦，没时间读书呀！我想说这话的人不是没时间读书，而是那个手机，它太好玩了，他们说的没时间，是玩了手机后没有时间。关于这点，两个凡是讲：凡是要等到有了实验室方才做研究的，有了实验室也不肯做研究；凡是要等到有了时间方才读书的，有了时间也不会去读书。</p><p>多读书，多体会别人面对各种情形时的判断和决策过程，这样，我们才能在面对复杂问题时提出妥善的解决方案，而不是如热锅上蚂蚁般团团转，撞了车也才不至于只懂得打电话找老公。多读书，使我们知道对问题的思考，往往不只一面，而是很多面，很可能还要翻一个面。我们要保持头脑开放，不能双脚踏在现代，而头脑还在宋代。爱因斯坦说过：“重大问题发生时，依我们当时的思想水准往往无法解决”。认知学上有个词叫“知识的错觉”：意思是说每个人懂的知识其实很少，但我们却以为自己懂得很多。我们不知道自己不知道，反而以为自己全知道，原因是我们把存在于他人大脑中的知识也看成是自己的。这就是我说的我们自己骗自己。我们面临的许多困难，其实并非真有多么困难，实乃我们见解上的困难，是书读少了的困难。</p><p>多读书，看览世间事，使我们知晓做人之道有时在于：含含糊糊的事要看得清清楚楚，而清清楚楚的事要显得含含糊糊。多读书，让我们知道不光要懂得积极工作的“生活技术”，还要懂得恋爱靠机会，而结婚靠智慧的“生活艺术”。多读书，我们还能保养自己的灵魂，尽量维持人生的幸福。许多人嘴上讲着保持精神上的纯粹，一讲都是满口的仁义道德，但他们肉体上却更加频繁地和俗事打着交道，食欲，睡欲，性欲，愤怒，骄傲和妒忌几乎成了他们维持生活的必需品。</p><p>多读书，能避免自己孤陋寡闻。书籍不但充实我们的灵魂，也同样减轻了我们精神上的痛苦，同时还可能解决我们面临的困难，这实在是很划算的事。诵读一册好书就是在不断地对话，书讲着，而我们的灵魂答着。当窗外阳光投射出的阴影从西边转到东边时，读者已经在书中看到了一个时代的兴亡、一种艺术的发展延续、一个人一生的得意与失落。虽然我们未环球旅行，但通过书籍，我们看到了现实的七大洲，并徜徉在心中的第八大洲。</p><p>多读书，明晰道理，使人聪明。聪明意味着遵循理智的指导，而愚蠢刚好相反，听任感情摆布，把理智限制于头脑的狭小角落里，而让感情囊括身体的其余部分。多读书，看别人犯的错，真正让自己谦逊。一个浮躁的人往往会急于为自己辩护，而辩护的结果又往往无济于事；一个勇于承认错误的人则给人一种尊贵、高尚的感觉。要知道：争辩永无止境，谦让受益更多! 发现自己的错误，需要智慧；承认错误，需要勇气；改正错误，则需要决心。</p><p>本文既是写给自己看，也帮助有需要的人。我很清楚，只有周围人的素质高了，社会才更理性，更安全，更有希望。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小杂感 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>自定义新闻邮件</title>
      <link href="/title/3af7bfc2/"/>
      <url>/title/3af7bfc2/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/08/19/mlBDsI.png" alt="mlBDsI.png"><br><a id="more"></a></p><h2 id="自定义邮件服务"><a href="#自定义邮件服务" class="headerlink" title="自定义邮件服务"></a>自定义邮件服务</h2><p>平时看新闻，发现各种新闻都是别人挑选出来给自己看的，尤其是利用深度学习算法，每个人都只能看到自己的想象中的世界。我特别讨厌这种情况，但是又挡不住媒体们的套路，所以我干脆自己设计了一个新闻邮件。该邮件从各大网站提取各行各业信息，确保信息题材的广泛。</p><h2 id="科技文"><a href="#科技文" class="headerlink" title="科技文"></a>科技文</h2><p>封面是从科学网站<a href="https://www.sciencemag.org/" target="_blank" rel="noopener">Science</a>提取的播客信息，可以一键听播客，也可以点击图片或标题阅读内容。</p><h2 id="社会类"><a href="#社会类" class="headerlink" title="社会类"></a>社会类</h2><p>目前打算开发中文版新闻邮件，采集政治，经济，科技，教育等类目新闻并实现每日推送。</p>]]></content>
      
      
      <categories>
          
          <category> 邮件服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT </tag>
            
            <tag> Mail </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C语言陷阱</title>
      <link href="/title/c1ec2509/"/>
      <url>/title/c1ec2509/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/10/30/K5YA5d.jpg" alt="ctraps"><br><a id="more"></a></p><h2 id="第1个陷阱：数组下标最大为n-1"><a href="#第1个陷阱：数组下标最大为n-1" class="headerlink" title="第1个陷阱：数组下标最大为n-1"></a>第1个陷阱：数组下标最大为n-1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int i, a[10];</span><br><span class="line">for (i = 0; i &lt;= 10; i++)</span><br><span class="line">a[i] = 0;            //a[10]可能存放的是变量i，所以会导致死循环</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt;= 9; i++)</span><br><span class="line">a[i] = 0;</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; 10; i++)</span><br><span class="line">a[i] = 0;           //推荐写法，i &lt; 10要比i &lt;= 9更好，10是出口,0是入口</span><br></pre></td></tr></table></figure><h2 id="第2个陷阱：同一符号的不同作用"><a href="#第2个陷阱：同一符号的不同作用" class="headerlink" title="第2个陷阱：同一符号的不同作用"></a>第2个陷阱：同一符号的不同作用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;s = &quot;-&gt;&quot;          // -&gt;是访问结构体 p-&gt;就是(*p)-&gt;的简写，&quot;-&gt;&quot;仅是一个字符串</span><br></pre></td></tr></table></figure><h2 id="第3个陷阱：赋值和比较运算符混用"><a href="#第3个陷阱：赋值和比较运算符混用" class="headerlink" title="第3个陷阱：赋值和比较运算符混用"></a>第3个陷阱：赋值和比较运算符混用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if (x = y)            //x == y误写为 x = y，若y不等于零，则程序侥幸能运行，难发现</span><br><span class="line">break; </span><br><span class="line"></span><br><span class="line">if ( (x = y) != 0)</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">while (c = &apos; &apos;||c==&apos;\t&apos;||c==&apos;\n&apos;)           //=符号运算优先级最低，&apos; &apos;为真，所以死循环</span><br><span class="line">c = getc(f);</span><br><span class="line"></span><br><span class="line">while (c == &apos;\t&apos; || c = &apos; &apos; || c == &apos;\n&apos;)   //等价于如下的赋值语句，会报错</span><br><span class="line">while (c == &apos;\t&apos; || c) = (&apos; &apos; || c == &apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">if ( (fd == open(argv[i], 0)) &lt; 0)          //比较结果为0或1，永远不小于0，所以error()永不执行</span><br><span class="line">error();</span><br><span class="line"></span><br><span class="line">if (c == 1);</span><br><span class="line">if (1 == c);          //凡是比较常量的，常量左写，让对的对，错一定让编译器抛出错</span><br></pre></td></tr></table></figure><h2 id="第4个陷阱：混用逻辑与或和位与或运算符，对齐"><a href="#第4个陷阱：混用逻辑与或和位与或运算符，对齐" class="headerlink" title="第4个陷阱：混用逻辑与或和位与或运算符，对齐"></a>第4个陷阱：混用逻辑与或和位与或运算符，对齐</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a &amp;&amp; b;</span><br><span class="line">a &amp; b;                // 若a &amp; b 不为0，则程序侥幸能运行</span><br><span class="line"></span><br><span class="line">parttab[] = &#123;</span><br><span class="line">046, &quot;left  s&quot;,   //为了对齐125, 46被写成046，而046是八进制数</span><br><span class="line">047, &quot;right r&quot;,</span><br><span class="line">125, &quot;frammis&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第5个陷阱：单目符号和多符号的贪心分析法则"><a href="#第5个陷阱：单目符号和多符号的贪心分析法则" class="headerlink" title="第5个陷阱：单目符号和多符号的贪心分析法则"></a>第5个陷阱：单目符号和多符号的贪心分析法则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a---b;               //编译器识别为a-- - b;</span><br><span class="line"></span><br><span class="line">n--&gt;0                //n-- &gt; 0 不同于n- -&gt;;</span><br><span class="line"></span><br><span class="line">a+++++b;             //(a++)++ +b，错误a++不做左值</span><br><span class="line"></span><br><span class="line">y = x/*p;            //到底是指针还是注释？x/(*p), x/*p?</span><br></pre></td></tr></table></figure><h2 id="第6个陷阱：’’和””的不同"><a href="#第6个陷阱：’’和””的不同" class="headerlink" title="第6个陷阱：’’和””的不同"></a>第6个陷阱：’’和””的不同</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">char *a;</span><br><span class="line">a = &quot;xyz&quot;            //&quot;xyz&quot;提供x的地址</span><br><span class="line"> </span><br><span class="line">char hello[] = &#123;&apos;H&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;,&apos; &apos;,&apos;w&apos;,&apos;o&apos;,&apos;r&apos;,&apos;l&apos;,&apos;d&apos;,&apos;\n&apos;,0&#125;;</span><br><span class="line">printf(hello);       </span><br><span class="line">                     //&apos; &apos;内为char或者说int，而&quot; &quot;括号内字符串常量</span><br><span class="line"></span><br><span class="line">printf(&quot;Hello world\n&quot;);</span><br><span class="line"></span><br><span class="line">printf(&apos;\n&apos;);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">c = &apos;yes&apos;;           //c可能等于y或者s，视不同机器的实现</span><br><span class="line">c = &quot;yes&quot;;</span><br></pre></td></tr></table></figure><h2 id="第7个陷阱：嵌套注释"><a href="#第7个陷阱：嵌套注释" class="headerlink" title="第7个陷阱：嵌套注释"></a>第7个陷阱：嵌套注释</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*&quot;/* &quot;*/</span><br></pre></td></tr></table></figure><h2 id="第8个陷阱：函数声明"><a href="#第8个陷阱：函数声明" class="headerlink" title="第8个陷阱：函数声明 "></a>第8个陷阱：函数声明 </h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(*(void(*)())0)();   //按照用的规则来，去掉哑变量</span><br><span class="line"> //(void(*)())是一种强制类型转换操作，类似于unsigned a</span><br><span class="line"> //它表示的是一个函数指针，且该指针指向的函数返回值为void型，且函数没有参数</span><br><span class="line"> //整个表达式是把0这个数转换为0这个位置，然后读取0位置的函数并执行</span><br><span class="line"> // (* (void (*)())0 )()</span><br><span class="line"> // (指针 类型转换 地址)()</span><br><span class="line">(*((*)())0)();       //默认返回类型为int，一般会出错，段错误，核心已转储</span><br><span class="line"></span><br><span class="line">float *g(), (*h)();</span><br><span class="line">(float (*)())        //指向返回值为浮点类型的函数指针的类型转换符号</span><br><span class="line"></span><br><span class="line">int func()&#123;&#125;</span><br><span class="line">(int (*)()) p = func;</span><br><span class="line">(*p)()               //简写为p() 但不是*p()，因为()优先和p结合</span><br></pre></td></tr></table></figure><h2 id="第9个陷阱：优先级别"><a href="#第9个陷阱：优先级别" class="headerlink" title="第9个陷阱：优先级别 "></a>第9个陷阱：优先级别 </h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(* / + -) &gt; (&lt;&lt; &gt;&gt;) &gt; (&gt; &lt; &gt;= &lt;= ==) &gt; (&amp;&amp; || !) &gt; (=) &gt; (? :) &gt; (,)</span><br><span class="line">                     //各种运算符号的优先级别，算术大于移位大于比较大于逻辑大于赋值大于三目运算大于逗号运算符号。</span><br><span class="line"></span><br><span class="line">FLAG = 01000100000;  //假设为二进制表示</span><br><span class="line">if (flags &amp; FLAG)    //flags &amp;&amp; FLAGE</span><br><span class="line">do sth;</span><br><span class="line"></span><br><span class="line">r = hi&lt;&lt;4 + low      //hi &lt;&lt; (4 + low)</span><br><span class="line">r = (hi&lt;&lt;4) + low;   //正确写法</span><br><span class="line">r = hi&lt;&lt;4 | low;     //这种写法也可，但hi得指高位，low指低位</span><br><span class="line"></span><br><span class="line">while (c = getc(in) != EOF) //c一直为1，直到文件末尾为0，可能导致对文件循环读取</span><br><span class="line">putc(c, stdout);</span><br></pre></td></tr></table></figure><h2 id="第10个陷阱：分号"><a href="#第10个陷阱：分号" class="headerlink" title="第10个陷阱：分号 "></a>第10个陷阱：分号 </h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if (x[i] &gt; big);     //big = x[i]一定会得到执行</span><br><span class="line">big = x[i]; </span><br><span class="line"></span><br><span class="line">if (n &lt; 3)          </span><br><span class="line">return           //return logre.date = x[0];</span><br><span class="line">logre.date = x[0];</span><br><span class="line">logre.time = x[1];</span><br><span class="line">logre.code = x[2];</span><br><span class="line"></span><br><span class="line">struct logrec&#123;</span><br><span class="line">int date;</span><br><span class="line">int time;</span><br><span class="line">int code;</span><br><span class="line">&#125;</span><br><span class="line">main()&#123;&#125;             //main函数返回类型为struct logrec类型</span><br></pre></td></tr></table></figure><h2 id="第11个陷阱：switch-省略break"><a href="#第11个陷阱：switch-省略break" class="headerlink" title="第11个陷阱：switch 省略break; "></a>第11个陷阱：switch 省略break; </h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">case &apos;\n&apos;:</span><br><span class="line">linecount++;     //故意省略break，可以继续执行下面的case</span><br><span class="line">case &apos;\t&apos;:</span><br><span class="line">case &apos; &apos;:</span><br></pre></td></tr></table></figure><h2 id="第12个陷阱：函数调用"><a href="#第12个陷阱：函数调用" class="headerlink" title="第12个陷阱：函数调用 "></a>第12个陷阱：函数调用 </h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f();                 //调用函数f</span><br><span class="line">f;                   //获得函数f的地址然后丢弃，什么也不做</span><br></pre></td></tr></table></figure><h2 id="第13个陷阱：悬挂else"><a href="#第13个陷阱：悬挂else" class="headerlink" title="第13个陷阱：悬挂else "></a>第13个陷阱：悬挂else </h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (x == 0)</span><br><span class="line">if (y == 0) error();</span><br><span class="line">else&#123;</span><br><span class="line">z = x + y;</span><br><span class="line">f(&amp;z);</span><br><span class="line">&#125;                    //else 按照最近匹配原则和内部if配对</span><br></pre></td></tr></table></figure><h2 id="第14个陷阱：数组和指针几乎等价"><a href="#第14个陷阱：数组和指针几乎等价" class="headerlink" title="第14个陷阱：数组和指针几乎等价 "></a>第14个陷阱：数组和指针几乎等价 </h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int *p, a[12];</span><br><span class="line">p = a;               //a既是数组名也是其首地址</span><br><span class="line">*a = 10;             //就是a[0] = 10</span><br><span class="line">*p = 10;             //也是a[0] = 10</span><br><span class="line">a[i]                 //可以写成i[a]或者a + i;</span><br><span class="line"></span><br><span class="line">char *r *malloc();                 //错误1:可能分配失败, 要检测r是否为NULL</span><br><span class="line">r = malloc(strlen(s) + strlen(t)); //错误2:缺少&apos;\0&apos;字符的存储位置</span><br><span class="line">strcpy(r,s);</span><br><span class="line">strcat(r,t);                       //错误3:未释放内存</span><br><span class="line">                     </span><br><span class="line">char r*, *malloc();  //一种可行的写法</span><br><span class="line">r = malloc(strlen(s) + strlen(t) + 1);</span><br><span class="line">if (!r)&#123;</span><br><span class="line">complain();</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">strcpy(r,s);</span><br><span class="line">strcat(r,t);</span><br><span class="line">&#125;</span><br><span class="line">free(r);</span><br><span class="line">p = NULL;</span><br></pre></td></tr></table></figure><h2 id="第15个陷阱：是数组还是指针做参数？"><a href="#第15个陷阱：是数组还是指针做参数？" class="headerlink" title="第15个陷阱：是数组还是指针做参数？ "></a>第15个陷阱：是数组还是指针做参数？ </h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int strlen(char s[])&#123;&#125;</span><br><span class="line">int strlen(char *s)&#123;&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)&#123;&#125; //等价于下面写法</span><br><span class="line">int main(int argc, char *argv[])&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="第16个陷阱：数组下标和指针访问"><a href="#第16个陷阱：数组下标和指针访问" class="headerlink" title="第16个陷阱：数组下标和指针访问"></a>第16个陷阱：数组下标和指针访问</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int cal[12][31];     //以下几种写法完全等价，有点儿绕</span><br><span class="line"></span><br><span class="line">cal[i][j], *(cal[i] + j), *(*(cal + i) + j)</span><br><span class="line">cal[i][j], *(i[cal] + j), j[i[cal]]</span><br></pre></td></tr></table></figure><h2 id="第17个陷阱：对操作优化"><a href="#第17个陷阱：对操作优化" class="headerlink" title="第17个陷阱：对操作优化 "></a>第17个陷阱：对操作优化 </h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#define N 1024</span><br><span class="line">static char buffer[N];</span><br><span class="line">static char *bufptr;</span><br><span class="line"></span><br><span class="line">void bufwrite(char *p, int n)</span><br><span class="line">&#123;</span><br><span class="line">while (--n &gt;= 0)&#123;</span><br><span class="line">if (bufptr == &amp;buffer[N])</span><br><span class="line">flushbuffer();</span><br><span class="line">*bufptr++ = *p++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void memcpy(char *dest, const char *source, int k)</span><br><span class="line">&#123;</span><br><span class="line">while (--k &gt;= 0)</span><br><span class="line">*dest++ = *source++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bufwrite(char *p, int n)</span><br><span class="line">&#123;                    //优化版，一次拷贝k个字符</span><br><span class="line">while (n &gt; 0)&#123;</span><br><span class="line">int k, rem;</span><br><span class="line">if (bufptr == &amp;buffer[N])</span><br><span class="line">flushbuffer();</span><br><span class="line"></span><br><span class="line">rem = N - (bufptr - buffer); //buffer + N - bufptr;</span><br><span class="line">k = n &gt; rem ? rem : n;</span><br><span class="line">memcpy(bufptr, p, k);</span><br><span class="line">bufptr += k;</span><br><span class="line">p += k;</span><br><span class="line">n -= k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第18个陷阱：求值顺序"><a href="#第18个陷阱：求值顺序" class="headerlink" title="第18个陷阱：求值顺序 "></a>第18个陷阱：求值顺序 </h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">f(x, y)              //函数有两个参数，求值顺序未定</span><br><span class="line">f( (x, y) )          //函数有一个参数，先求x，再求y</span><br><span class="line"></span><br><span class="line">i = 0;</span><br><span class="line">while (i &lt; n)</span><br><span class="line">y[i] = x[i++];   //错误，i++求值顺序未定</span><br><span class="line">y[i++] = x[i];   //错误，i++求值顺序未定</span><br><span class="line"></span><br><span class="line">i = 0;</span><br><span class="line">while (i &lt; n)</span><br><span class="line">y[i] = x[i];     //正确</span><br><span class="line">++i;</span><br><span class="line"></span><br><span class="line">i = 0</span><br><span class="line">for (;i &lt; n; ++i)    //正确</span><br><span class="line">y[i] = x[i];</span><br></pre></td></tr></table></figure><h2 id="第19个陷阱：-amp-amp"><a href="#第19个陷阱：-amp-amp" class="headerlink" title="第19个陷阱：&amp;&amp; || !"></a>第19个陷阱：&amp;&amp; || !</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = 0;               //&amp;&amp;误用为&amp;，若&amp;操作结果为零才能发现此错误</span><br><span class="line">while (i &lt; tabsize &amp; tab[i] != x) </span><br><span class="line">i++;</span><br></pre></td></tr></table></figure><h2 id="第20个陷阱：数溢出"><a href="#第20个陷阱：数溢出" class="headerlink" title="第20个陷阱：数溢出 "></a>第20个陷阱：数溢出 </h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ((unsigned)a + (unsigned)b &gt; INT_MAX)</span><br><span class="line">complain();      //加法溢出时，若检测溢出位标志会失败</span><br><span class="line">                    </span><br><span class="line">if (a &gt;INT_MAX - b)  //最好用减法，减法防止溢出，</span><br><span class="line">complain();</span><br></pre></td></tr></table></figure><h2 id="第21个陷阱：main-函数无返回值"><a href="#第21个陷阱：main-函数无返回值" class="headerlink" title="第21个陷阱：main 函数无返回值 "></a>第21个陷阱：main 函数无返回值 </h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;hello world!\n&quot;);</span><br><span class="line">&#125;                    //返回垃圾整数，导致操作系统误判程序执行失败，而实际又执行成功了</span><br><span class="line"></span><br><span class="line">int main(int argc, char **)</span><br><span class="line">&#123;                    </span><br><span class="line">printf(&quot;hello world!\n&quot;);</span><br><span class="line">return 0;        //一种可行的写法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第22个陷阱：声明和引用"><a href="#第22个陷阱：声明和引用" class="headerlink" title="第22个陷阱：声明和引用 "></a>第22个陷阱：声明和引用 </h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a;               //a未赋值，则默认为0</span><br><span class="line">int b = 1;</span><br><span class="line">extern int c;        //引用外部变量</span><br><span class="line">static int d;        //限制d在该文件，不可被外部引用</span><br></pre></td></tr></table></figure><h2 id="第23个陷阱：调用外部函数要声明参数类型"><a href="#第23个陷阱：调用外部函数要声明参数类型" class="headerlink" title="第23个陷阱：调用外部函数要声明参数类型 "></a>第23个陷阱：调用外部函数要声明参数类型 </h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int isvowel(char);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a;</span><br><span class="line">char c;</span><br><span class="line"></span><br><span class="line">c = &apos;a&apos;;</span><br><span class="line">a = isvowel(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第24个陷阱：变量类型错误使用"><a href="#第24个陷阱：变量类型错误使用" class="headerlink" title="第24个陷阱：变量类型错误使用"></a>第24个陷阱：变量类型错误使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">char c;</span><br><span class="line">for (i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;c);   //%c还是%d? </span><br><span class="line">printf(&quot;%d &quot;, i);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第25个陷阱：外部变量类型引用时声明错误"><a href="#第25个陷阱：外部变量类型引用时声明错误" class="headerlink" title="第25个陷阱：外部变量类型引用时声明错误 "></a>第25个陷阱：外部变量类型引用时声明错误 </h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long n;</span><br><span class="line">extern int n;       //到底用long 还是int?</span><br></pre></td></tr></table></figure><h2 id="第26个陷阱：缓冲区释放错误"><a href="#第26个陷阱：缓冲区释放错误" class="headerlink" title="第26个陷阱：缓冲区释放错误 "></a>第26个陷阱：缓冲区释放错误 </h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">static char buf[BUFSIZ]; //正确位置</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int c;</span><br><span class="line">char buf[BUFSIZ];    //错误位置，放在此处，main执行完buf就没了，释放buf时出错</span><br><span class="line">setbuf(stdout, buf)  //最好作为main函数第一句</span><br><span class="line"></span><br><span class="line">while ((c = getchar()) != EOF)</span><br><span class="line">putchar(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第27个陷阱：宏定义缺少必要的括号"><a href="#第27个陷阱：宏定义缺少必要的括号" class="headerlink" title="第27个陷阱：宏定义缺少必要的括号 "></a>第27个陷阱：宏定义缺少必要的括号 </h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#define abs(x) x &gt;= 0 ? x : -x</span><br><span class="line">abs(a-b)                 //a - b &gt;= 0 ? a - b : -a-b 此处错误，应为-(a-b)</span><br><span class="line">abs(a) + 1               //a &gt;= 0 ? a : -a + 1       又错   </span><br><span class="line">#define abs(x) ((x) &gt;= 0 ?(x):-(x)) //良定义</span><br><span class="line"></span><br><span class="line">#define max(biggest, x)  ((biggest) &gt; (x) ? (bigget) : (x))</span><br><span class="line">max(bigest, x[i++])      //宏中最好不要有带有副作用的操作存在，类似i++</span><br><span class="line">max(a,max(b,max(c,d)))   //宏定义展开过长 </span><br><span class="line">max(max(a,b),max(c,d))   //((((a)&gt;(b)?(a):(b)))&gt;(((c)&gt;(d)?(c):(d)))?(((a)&gt;(b)?(a):(b))):(((c)&gt;(d)?(c):(d))))</span><br><span class="line"></span><br><span class="line">bigest = a;              //一种比较a,b,c,d的好方法，代码清晰</span><br><span class="line">if (bigest &lt; b) bigest = b;</span><br><span class="line">if (bigest &lt; c) bigest = c;</span><br><span class="line">if (bigest &lt; d) bigest = d;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define assert(e) if (!e) assert_error(__FILE__,__LINE__)</span><br><span class="line">if (x &gt; 0 &amp;&amp; y &gt; 0)</span><br><span class="line">assert(x &gt; y);       //展开后if和else匹配出错</span><br><span class="line">else</span><br><span class="line">assert(x &lt; y);</span><br><span class="line">#define assert(e) &#123; if (!e) assert_error(__FILE__,__LINE__) &#125;</span><br><span class="line">if (x &gt; 0 &amp;&amp; y &gt; 0)</span><br><span class="line">assert(x &gt; y);       //解决了if和else配对，但会在&#125;后多一个; </span><br><span class="line">else</span><br><span class="line">assert(x &lt; y);</span><br><span class="line"> //一种可行的写法</span><br><span class="line">#define assert(e) ((void)((e)||_assert_error(__FILE__,__LINE__)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define T1 struct foo *</span><br><span class="line">typedef struct foo *T2</span><br><span class="line">T1 a, b;                 //struct foo *a, b ，此处b的类型不对</span><br><span class="line">T2 a, b;                 //struct foo *a, *b, 正确</span><br></pre></td></tr></table></figure><h2 id="第28个陷阱：编译器不区分大小写"><a href="#第28个陷阱：编译器不区分大小写" class="headerlink" title="第28个陷阱：编译器不区分大小写 "></a>第28个陷阱：编译器不区分大小写 </h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char * Malloc(unsigned n) //Malloc等于是malloc</span><br><span class="line">&#123;</span><br><span class="line">char *p, *malloc(unsigned); </span><br><span class="line">p = malloc(n);        //循环调用自身，内存被耗尽，系统崩溃</span><br><span class="line">if (p == NULL)</span><br><span class="line">panic(&quot;out of memory&quot;);</span><br><span class="line">return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第29个陷阱：字符有无符号"><a href="#第29个陷阱：字符有无符号" class="headerlink" title="第29个陷阱：字符有无符号 "></a>第29个陷阱：字符有无符号 </h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(unsigned char) c;        //强制声明无符号</span><br></pre></td></tr></table></figure><h2 id="第30个陷阱：乘除2的倍数用移位"><a href="#第30个陷阱：乘除2的倍数用移位" class="headerlink" title="第30个陷阱：乘除2的倍数用移位 "></a>第30个陷阱：乘除2的倍数用移位 </h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mid  = (low + high) &gt;&gt; 2; //除以4</span><br><span class="line">mid  = low &lt;&lt; 2;          //乘以2</span><br></pre></td></tr></table></figure><h2 id="第31个陷阱：空指针位置0的读写权限"><a href="#第31个陷阱：空指针位置0的读写权限" class="headerlink" title="第31个陷阱：空指针位置0的读写权限 "></a>第31个陷阱：空指针位置0的读写权限 </h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char *p;</span><br><span class="line">p = NULL;             //空指针一般不可写，可读与否看系统</span><br><span class="line">printf(&quot;Location 0 contains %d\n&quot;,*p);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第32个陷阱：负数成了被除数"><a href="#第32个陷阱：负数成了被除数" class="headerlink" title="第32个陷阱：负数成了被除数 "></a>第32个陷阱：负数成了被除数 </h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">h = n % HASHSIZE;         // n小于0时，结果未定义</span><br><span class="line">if (h &lt; 0)</span><br><span class="line">h += HASHSIZE;</span><br><span class="line"></span><br><span class="line">h = (unsigned n) % HASHSIZE; //强制无符号</span><br></pre></td></tr></table></figure><h2 id="第33个陷阱：部分宏定义无法判断字符的范围"><a href="#第33个陷阱：部分宏定义无法判断字符的范围" class="headerlink" title="第33个陷阱：部分宏定义无法判断字符的范围 "></a>第33个陷阱：部分宏定义无法判断字符的范围 </h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#define toupper(c) ((c)+&apos;A&apos;-&apos;a&apos;)</span><br><span class="line">#define tolower(c) ((c)+&apos;a&apos;-&apos;A&apos;)</span><br><span class="line"></span><br><span class="line">int c;</span><br><span class="line">while ((c = getchar()) != EOF)</span><br><span class="line">putchar(tolower(c));  //错误，c可能就是小写字符</span><br><span class="line">putchar(toupper(c));  //错误，c可能就是大写字符</span><br><span class="line">  </span><br><span class="line">int c;                    //一种可行的写法</span><br><span class="line">while ((c = getchar()) != EOF)</span><br><span class="line">putchar(isupper(c) ? tolower(c) : c);</span><br><span class="line">putchar(islower(c) ? toupper(c) : c);</span><br><span class="line"></span><br><span class="line">int toupper (int c)       //或者使用函数</span><br><span class="line">&#123;</span><br><span class="line">if (c &gt;= &apos;a&apos; &amp;&amp; c &lt;= &apos;z&apos;)</span><br><span class="line">return c + &apos;A&apos; - &apos;a&apos;;</span><br><span class="line">&#125;                         //同时也有宏，选择使用一种</span><br><span class="line">#define _toupper(c) ((c)+&apos;A&apos;-&apos;a&apos;)</span><br><span class="line">#define _tolower(c) ((c)+&apos;a&apos;-&apos;A&apos;)</span><br></pre></td></tr></table></figure><h2 id="第34个陷阱：释放内存"><a href="#第34个陷阱：释放内存" class="headerlink" title="第34个陷阱：释放内存"></a>第34个陷阱：释放内存</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct node *p, *head;</span><br><span class="line">for (p = head; p; p = p-&gt;next)</span><br><span class="line">free((char *)p);      //此处释放了，p-&gt;next仍正确，但再次循环就会出错</span><br><span class="line"></span><br><span class="line">struct node *p, *head, *tmp;</span><br><span class="line">for (p = head; p; p = tmp)</span><br><span class="line">tmp = p -&gt; next;      //使用临时指针缓存</span><br><span class="line">free((char *)p);</span><br></pre></td></tr></table></figure><h2 id="第35个陷阱：默认数组递增序列"><a href="#第35个陷阱：默认数组递增序列" class="headerlink" title="第35个陷阱：默认数组递增序列"></a>第35个陷阱：默认数组递增序列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void printnum(long n, void (*p)())</span><br><span class="line">&#123;</span><br><span class="line">if ( n &lt; 0)&#123;</span><br><span class="line">(*p)(&apos;-&apos;);</span><br><span class="line">n = -n;</span><br><span class="line">&#125;</span><br><span class="line">if ( n &gt;= 10)</span><br><span class="line">printnum( n / 10,p);</span><br><span class="line"></span><br><span class="line">(*p)((int)(n%10) + &apos;0&apos;);    //+号，暗含所有数按序编排，实际可能不是这样</span><br><span class="line">&#125;</span><br><span class="line">(*p)(&quot;0123456789&quot;[n % 10]); //此写法可行，字符串作为数组名，</span><br><span class="line">//提供了首地址，n % 10作为下标取其中的字符</span><br></pre></td></tr></table></figure><h2 id="第36个陷阱：指针不可直接相加，可相减，单独加数"><a href="#第36个陷阱：指针不可直接相加，可相减，单独加数" class="headerlink" title="第36个陷阱：指针不可直接相加，可相减，单独加数"></a>第36个陷阱：指针不可直接相加，可相减，单独加数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int func()</span><br><span class="line">&#123;</span><br><span class="line">char s[10];</span><br><span class="line">char *p1, p2;</span><br><span class="line">char *mid;</span><br><span class="line"></span><br><span class="line">p1 = s, </span><br><span class="line">p2 = &amp;s[9];</span><br><span class="line">mid = (p1 + p2) / 2         //错误，不可相加</span><br><span class="line">mid = (p1 + p2) &gt;&gt;1         //错误，不可相加</span><br><span class="line"></span><br><span class="line">mid = (p2 - p1)/2  + p1     //正确，指针p1可以加数</span><br><span class="line">mid = (p2 - p1) &gt;&gt; 1 + p1   //错误，+ 优先级高</span><br><span class="line">mid = ((p2-p1)&gt;&gt;1) + p1     //正确</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第37个陷阱：空指针引发段错误，核心转储"><a href="#第37个陷阱：空指针引发段错误，核心转储" class="headerlink" title="第37个陷阱：空指针引发段错误，核心转储"></a>第37个陷阱：空指针引发段错误，核心转储</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">char s[100];</span><br><span class="line">p = malloc(strlen(s) + 1);      </span><br><span class="line">if (p)</span><br><span class="line">do sth;</span><br><span class="line">else</span><br><span class="line">exit(1);</span><br><span class="line"></span><br><span class="line">free(p);</span><br><span class="line">p = NULL;                       //把指针给管起来</span><br><span class="line">char s[100];</span><br><span class="line">p = malloc(strlen(s) + 1);      </span><br><span class="line">if (p)</span><br><span class="line">do sth;</span><br><span class="line">else</span><br><span class="line">exit(1);</span><br><span class="line"></span><br><span class="line">free(p);</span><br><span class="line">p = NULL;                       //把指针给管起来</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于glibc中strcmp函数的其他几种写法</title>
      <link href="/title/6e24e863/"/>
      <url>/title/6e24e863/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/10/30/K5JvCR.jpg" alt="gnu"><br><a id="more"></a></p><h1 id="glibc"><a href="#glibc" class="headerlink" title=" glibc"></a> glibc</h1><p><a href="https://www.gnu.org/" target="_blank" rel="noopener">GNU</a>组织实现的C运行库，是Linux系统最底层的API。</p><ol><li>strcmp</li></ol><hr><p>strcmp, <strong>String Compare Function</strong>, compare S1 and S2, returning less than, equal to or greater than zero if S1 is lexicographically less than, equal to or greater than S2. 字符串S1中字符一旦大于S2中的字符就返回大于零的数(两字符差值)，小于就返回小于零的数，等于就返回零。</p><h2 id="2-由头"><a href="#2-由头" class="headerlink" title="2.由头"></a>2.由头</h2><p>最近看书，发现C语言指针和数组特别神奇，很多复杂的函数，只要有指针就能简化代码。刚好在glic中发现字符串比较函数strcmp的官方写法，自己又结合书籍整理了一番，提出了几个自己写的版本。</p><h2 id="3-自定义版"><a href="#3-自定义版" class="headerlink" title="3.自定义版"></a>3.自定义版</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">int strcmp0(char *p1, char *p2)</span><br><span class="line">&#123;   //最简单的写法，指针当数组用</span><br><span class="line">int i;</span><br><span class="line">for (i = 0; p1[i] == p2[i]; i++)&#123;</span><br><span class="line">if (p1[i] == &apos;\0&apos;)</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">return p1[i] - p2[i];</span><br><span class="line"></span><br><span class="line">int strcmp1(char *p1, char *p2)</span><br><span class="line">&#123;//数组下标自增</span><br><span class="line">int i = 0;</span><br><span class="line">for (; p1[i] == p2[i];)&#123;</span><br><span class="line">if (p1[i++] == &apos;\0&apos;)</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">return p1[i] - p2[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int strcmp2(char *p1, char *p2)</span><br><span class="line">&#123;//使用指针取值</span><br><span class="line">for (; *p1 == *p2; p1++, p2++)&#123;</span><br><span class="line">if (*p1 == &apos;\0&apos;)</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">return *p1 - *p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int strcmp3(char *p1, char *p2)</span><br><span class="line">&#123;//放弃判断&apos;\0&apos;，而用!取反</span><br><span class="line">for (; *p1 == *p2; p1++, p2++)&#123;</span><br><span class="line">if (!*p1)</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">return *p1 - *p2;</span><br><span class="line"></span><br><span class="line">int strcmp4(char *p1, char *p2)</span><br><span class="line">&#123;//指针自增，注意*--p1中*和--的优先级，此法最简，不知有错没？</span><br><span class="line">while (*p1++ == *p2++);</span><br><span class="line">return *--p1 - *--p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-官方版"><a href="#4-官方版" class="headerlink" title="4.官方版"></a>4.官方版</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int </span><br><span class="line">STRCMP(const char *p1, const char *p2)</span><br><span class="line">&#123;</span><br><span class="line">  const unsigned char *s1 = (const unsigned char *) p1;</span><br><span class="line">  const unsigned char *s2 = (const unsigned char *) p2;</span><br><span class="line">  unsigned char c1, c2;</span><br><span class="line"></span><br><span class="line">  do</span><br><span class="line">&#123;</span><br><span class="line">  c1 = (unsigned char) *s1++;</span><br><span class="line">  c2 = (unsigned char) *s2++;</span><br><span class="line">  if (c1 == &apos;\0&apos;)</span><br><span class="line">return c1 - c2;</span><br><span class="line">&#125;</span><br><span class="line">  while (c1 == c2);</span><br><span class="line"></span><br><span class="line">  return c1 - c2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-结语"><a href="#5-结语" class="headerlink" title="5.结语"></a>5.结语</h2><p>看了官方版本，感觉自己还很有差距。C语言灵活，但太容易出错，指针简直就是一把瑞士尖刀，弄不好就要戳到自己身上。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux上可用的文献目录管理工具</title>
      <link href="/title/4388879e/"/>
      <url>/title/4388879e/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/10/30/K5JHDU.md.png" alt="bibliography"><br><a id="more"></a></p><p>针对文献管理，Linux有很多的解决方案。借助BibTex的力量，这些工具可以帮你导入引用源，然后自动生成一个结构化文献目录。这里给大家提供了一些Linux上参考文献管理工具的不完全列表。</p><ol><li><p>Zotero<br>这应该是最著名的参考文献聚集工具，Zotero作为一个浏览器的扩展插件。当然，它也有一个方便的Linux 独立工具。拥有强大的性能，Zotero 很容易上手，并且也可以和LibreOffice 或者是其他的文本编辑器配套使用来管理文档的参考文献。我个人很欣赏其操作界面和插件管理器。可惜的是，如果你对参考文献有很多不同的需求的话，很快就会发现 Zotero 功能有限。</p></li><li><p>JabRef<br>JabRef 是最先进的文献管理工具之一。你可以导入大量的格式，可以在其外部的数据库里查找相应的条目（像Google Scholar），并且能直接输出到你喜欢的编辑器。JabRef 可以很好的兼容你的运行环境，甚至也支持插件。最后还有一点，JabRef可以连接你自己的SQL 数据库。而唯一的缺点就是其学习使用的难度。</p></li><li><p>KBibTex<br>对于 KDE 使用者，这个桌面环境也拥有它自己专有的文献管理工具KBibTex。这个程序的品质，正如你所期望。程序可高度定制，通过快捷键就可以很好的操作和体验。你可以很容易找到副本、可以预览结果、也可以直接输出到LaTex 编辑器。而我认为这款软件最大的特色在于它集成了Bigsonomy ，Google Scholar ，甚至是你的Zotero账号。唯一的缺憾是界面看起来实在是有点乱。多花点时间设置软件可以让你使用起来得心应手。</p></li><li><p>Bibfilex<br>可以运行在Gtk 和Qt 环境中，Bibfilex是一个基于 Biblatex 的界面友好的工具。相对于JabRef 和KBibTex ，缺少了一些高级的功能，但这也让他更加的快速和轻巧。不用想太多，这绝对是快速做文献目录的一个聪明的选择。界面很舒服，仅仅反映了一些必要的功能。我给出了其使用的完全手册，你可以从官方的下载页面去获得。</p></li><li><p>Pybliographer<br>正如它的名字一样，Pybliographer是一个用 Python 写的非图形化的文献目录管理工具。我个人比较喜欢把Pybiographic 当做是图形化的前端。它的界面极其简洁和抽象。如果你仅仅需要输出少数的参考文献，而且也确实没有时间去学习更多的工具软件，那么 Pybliographer 确实是一个不错的选择。有一点点像 Bibfilex 的是，它是以让用户方便、快速的使用为目标的。</p></li><li><p>Referencer<br>这应该是我归纳这些时候的一个最大的惊喜，Referencer 确实是让人眼前一亮。完美兼容 Gnome ，它可以查找和导入你的文档，然后在网上查询他们的参考文献，并且输出到 LyX ，非常的漂亮和设计良好。为数不多的几个快捷键和插件让它拥有了图书馆的风格。</p></li><li><p>Mendeley<br>用了Mendeley，一拖一点完事。Mendeley的PDF导入与识别能力非常强大，尤其是对期刊全文PDF。只要将PDF文件拖入Mendeley，它能自动识别Titile， Author， Publication， Year，但有时候识别是不准确的。</p></li><li><p>Bibus<br>BiBus基于Python，Windows和Linux版本都有，Ubuntu下安装Bibus只要敲 sudo apt-get install bibus。要注意的一点是第一次使用前要选择数据库，MySQL或SQLite任选其一。如果是个人使用，最好选择SQLite，具体按提示搞就OK了。然后就需要导入文献数据库，去PubMed主页，搜索关键词，在搜索结果列表中选中一堆你想要的文章，把文字信息导入某个txt文件，打开BiBus(在Applications-Office-BiBus），选择菜单File-Import-Medline，选择txt文件，数据库就显示在BiBus左侧的Import Buffer目录了。使用：点击每篇文献，下方就会显示作者标题摘要等信息；你可以拖动文献到左侧References目录，可以右键点击References目录，选择Add Child增加子目录，也可以手动新建文献资料。</p></li><li><p>Docear<br>配合Zotero使用效果最好，这Docear是基于思维导图形式的文献管理工具，给人耳目一新的感觉，这也是Docear的一大特色，但是Docear的文献管理方面不如Zotero。</p></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://blog.csdn.net/yangtou882/article/details/51296120" target="_blank" rel="noopener">Zoteror和Docear</a></p><p>via: <a href="http://xmodulo.com/reference-management-software-linux.html" target="_blank" rel="noopener">http://xmodulo.com/reference-management-software-linux.html</a> ,原文有增删</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux下自定义位置安装TeXLive2019</title>
      <link href="/title/46ed9a72/"/>
      <url>/title/46ed9a72/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/10/30/K5J53q.md.jpg" alt="texlive"><br><a id="more"></a></p><h2 id="1-从清华大学的镜像处下载"><a href="#1-从清华大学的镜像处下载" class="headerlink" title="1.从清华大学的镜像处下载"></a>1.从清华大学的镜像处下载</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/</span><br></pre></td></tr></table></figure><h2 id="2-安装图像化界面必备的perl-tk组件"><a href="#2-安装图像化界面必备的perl-tk组件" class="headerlink" title="2.安装图像化界面必备的perl-tk组件"></a>2.安装图像化界面必备的perl-tk组件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install perl-tk</span><br></pre></td></tr></table></figure><h2 id="3-把下载好的-iso文件挂载到-mnt下"><a href="#3-把下载好的-iso文件挂载到-mnt下" class="headerlink" title="3.把下载好的.iso文件挂载到/mnt下"></a>3.把下载好的.iso文件挂载到/mnt下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -t iso9660 -o loop texlive2019-20190410.iso /mnt</span><br></pre></td></tr></table></figure><h2 id="4-准备从图形界面安装"><a href="#4-准备从图形界面安装" class="headerlink" title="4.准备从图形界面安装"></a>4.准备从图形界面安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /mnt</span><br><span class="line">sudo ./install-tl -gui</span><br></pre></td></tr></table></figure><h2 id="5-如果要修改安装位置请执行-目录下面空间够用也可不用管这一步"><a href="#5-如果要修改安装位置请执行-目录下面空间够用也可不用管这一步" class="headerlink" title="5.如果要修改安装位置请执行(/目录下面空间够用也可不用管这一步)"></a>5.如果要修改安装位置请执行(/目录下面空间够用也可不用管这一步)</h2><pre><code>在&quot;TEXDIR(主TeX目录)&quot; 一行后点修改，填入新的位置(如/home/texlive2019)</code></pre><h2 id="6-可以瘦身安装-空间够此步也可忽略"><a href="#6-可以瘦身安装-空间够此步也可忽略" class="headerlink" title="6.可以瘦身安装(空间够此步也可忽略)"></a>6.可以瘦身安装(空间够此步也可忽略)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;安装字体/宏包文档目录树&quot;　切换为否</span><br><span class="line">&quot;安装字体/宏包源代码目录树&quot;　切换为否</span><br><span class="line">上面两个操作会舍弃安装文档和源代码，实际上大部分人也不会看，安装了浪费2G左右空间</span><br></pre></td></tr></table></figure><h2 id="7-点击安装TeX-Live"><a href="#7-点击安装TeX-Live" class="headerlink" title="7.点击安装TeX Live"></a>7.点击安装TeX Live</h2><h2 id="8-卸载镜像文件"><a href="#8-卸载镜像文件" class="headerlink" title="8.卸载镜像文件"></a>8.卸载镜像文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo unmount /mnt</span><br></pre></td></tr></table></figure><h2 id="9-配置字体-不配置的话，无法使用TeXLive自带字体"><a href="#9-配置字体-不配置的话，无法使用TeXLive自带字体" class="headerlink" title="9.配置字体(不配置的话，无法使用TeXLive自带字体)"></a>9.配置字体(不配置的话，无法使用TeXLive自带字体)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /home/tex2019/2019/texmf-var/fonts/conf/texlive-fontconfig.conf /etc/fonts/conf.d/09-texlive.conf</span><br><span class="line">sudo fc-cache -fsv (此步执行时间稍长)</span><br></pre></td></tr></table></figure><h2 id="10-环境变量设置"><a href="#10-环境变量设置" class="headerlink" title="10.环境变量设置"></a>10.环境变量设置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">打开~/.bashrc 在最后加入如下内容(具体路径安按照自己的系统修改)</span><br><span class="line"></span><br><span class="line">export TexMan=&quot;/home/tex2019/2019/texmf-dist/doc/man&quot;</span><br><span class="line">export TexInfo=&quot;/home/tex2019/2019/texmf-dist/doc/info&quot;</span><br><span class="line">export TexLive=&quot;/home/tex2019/2019/bin/x86_64-linux&quot;</span><br><span class="line">export MANPATH=&quot;$MANPATH:$TexMan&quot;</span><br><span class="line">export INFOPATH=&quot;$INFOPATH:$TexInfo&quot;</span><br><span class="line">export PATH=&quot;$PATH:$TexLive&quot;</span><br><span class="line"></span><br><span class="line">执行 source ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="11-更新源配置"><a href="#11-更新源配置" class="headerlink" title="11.更新源配置"></a>11.更新源配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo tlmgr option repository https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnet</span><br><span class="line">此步如果出现sudo;找不到命令 tlmgr，意味着执行时环境变量不对，请执行</span><br><span class="line">(1) sudo vi /etc/sudoers</span><br><span class="line">(2) 给如下内容加一个感叹号</span><br><span class="line">Defaultsenv_reset </span><br><span class="line">Defaults!env_reset</span><br><span class="line">(3) 再vi ~/.bashrc 加入下面这行到最后</span><br><span class="line">(4) alias sudo=&apos;sudo env PATH=$PATH&apos;</span><br><span class="line">(5) 保存退出执行 source ~/.bashrc</span><br><span class="line">此时再执行第一条命令 sudo tlmgr option ....</span><br></pre></td></tr></table></figure><h2 id="12-更新宏包"><a href="#12-更新宏包" class="headerlink" title="12.更新宏包"></a>12.更新宏包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo tlmgr update --self --all </span><br><span class="line">要更新几百个，时间较长</span><br></pre></td></tr></table></figure><h2 id="13-解决软件安装依赖问题"><a href="#13-解决软件安装依赖问题" class="headerlink" title="13.解决软件安装依赖问题"></a>13.解决软件安装依赖问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(1) sudo apt-get install aptitude</span><br><span class="line">(2) sudo aptitude install equivs</span><br><span class="line">(3) sudo mkdir /tmp/tl-equivs &amp;&amp; cd /tmp/tl-equivs</span><br><span class="line">(4) equivs-control texlive-local</span><br><span class="line">(5) 浏览器打开https://www.tug.org/texlive/files/debian-equivs-2019-ex.txt并复制所有内容</span><br><span class="line">(6) sudo vi texlive-local 将从浏览器拷贝的内容粘贴进去并保存退出</span><br><span class="line">(7) sudo equivs-build texlive-local</span><br><span class="line">(8) sudo apt-get freeglut3</span><br><span class="line">(9) sudo dpkg -i texlive-local_2019-1_all.deb</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 排版设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tex </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关系数据库，非关系数据库，云原生数据库</title>
      <link href="/title/d8ef31cc/"/>
      <url>/title/d8ef31cc/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/10/30/K5JgHg.md.png" alt="database"><br><a id="more"></a></p><h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><p>最近在研究学习数据库知识，发现市面上太多数据库及其书籍，而且体系混乱，越看越糊涂，故特意了解了数据库的发展史。</p><p>最早提出关系型数据库原理的是E.F.Codd，他在其论文<a href="https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf" target="_blank" rel="noopener">A Relational Model of Data for Large Shared Data Banks</a>中详述了关系数据库的原理和实现，我看了下论文，和今天的数据库简直一模一样。</p><p>而非关系数据库NoSQL一词首先是Carlo Strozzi在1998年提出来的，指的是他开发的一个没有SQL功能，轻量级的，开源的关系型数据库。这个定义跟我们现在对NoSQL的定义有很大的区别，它本来指的就是“没有SQL”的数据库，但是NoSQL的发展慢慢偏离了初衷，我们要的不是“no sql”，而是“no relational”，也就是我们现在常说的非关系型数据库。</p><p>2009年初，Johan Oskarsson举办了一场关于开源分布式数据库的讨论，Eric Evans在这次讨论中再次提出了NoSQL一词，用于指代那些非关系型的，分布式的，且一般不保证遵循ACID原则的数据存储系统。Eric Evans使用NoSQL这个词，并不是因为字面上的“没有SQL”的意思，他只是觉得很多经典的关系型数据库名字都叫“xxxSQL”,所以为了表示跟这些关系型数据库在定位上的截然不同，就是用了“NoSQL“一词。</p><p>随着社会的发展，不同时代对数据处理和存储的需求在不断变化，故而可以预见的是，数据库会不断有新品种诞生，老品种过时退出市场。今天历史偶然地走上了大数据和智能的时代，所以未来数据一定是很重要的一块，而数据库由于其特殊地位，应当得到极大的发展。我预计，未来10-20年应该会诞生数种新的广泛流行使用的数据库，满足的需求应当是切合时代要求的。中国的数据库厂商应该要有眼光锁定未来市场。为什么? 因为我们有最多的人口，倘使10年后每个中国人都要接入网络，每天产生1G的数据，那么一年，14甚至15亿人口是什么概念？古代有县志，史书。而现代人也当考虑如何将我们丰富的生活和文化保留给后人研究，所以大型的数据库必然会出现，建立人类数据库势在必行，可能下一个创业点也在此。</p><p>在我的认识里，数据库除了存储还要满足对关系的映射，这里关系包含传统的关系数据库关系，也包含非关系数据库的关系。嗯？非关系数据库还有关系？是的，没有消息就是消息，没有关系也是关系。数据总是有结构存在的，目前的成熟产品不一定能应对未来的场景，此间到底还有多少可以挖掘的知识就需要一代代人慢慢摸索。<br>若干年来，数据库一直锁定在大厂商手里，下面略谈一些。</p><h1 id="二-数据库大厂"><a href="#二-数据库大厂" class="headerlink" title="二 数据库大厂"></a>二 数据库大厂</h1><p>做数据库的大厂商目前有七家(排名不分先后)。</p><blockquote><p>   <strong>SAP</strong>，企业资源计划系统里的佼佼者。<br>    <strong>AWS</strong>，Amazon巨头，卖东西卖出大机遇。<br>    <strong>IBM</strong>，百年老牌，现代计算机结构的奠基者。<br>    <strong>Google</strong>，不作恶，偏学好，引领时代精神。<br>    <strong>Oracle</strong>，甲骨文，专注于闭源的杰出代表。<br>    <strong>Aliyun</strong>，阿里巴巴，人人夸。<br>    <strong>MicroSoft</strong>，Windows 发扬者。</p></blockquote><h1 id="二-关系型数据库"><a href="#二-关系型数据库" class="headerlink" title="二 关系型数据库"></a>二 关系型数据库</h1><p>常见的关系数据库如下：</p><blockquote><p>   <strong>DB2</strong> 是IBM一种分布式数据库解决方案，是IBM开发的一种大型关系型数据库平台。支持多用户或程序在同一条SQL 语句中查询不同database甚至DBMS中的数据。<br>    <strong>Oracle</strong> 是甲骨文公司的一款关系数据库管理系统。它是在数据库领域一直处于领先地位的产品。可以说Oracle数据库系统是目前世界上流行的关系数据库管理系统。<br>    <strong>MySQL</strong> 是一种开放源代码的关系型数据库管理系统，使用最常用的数据库管理语言结构化查询语言（SQL）进行数据库管理。<br>    <strong>MariaDB</strong> 是MySQL的一个分支，主要由开源社区在维护，由MySQL创始人开发。MariaDB完全兼容MySQL，使之能轻松成为MySQL的代替品。使用XtraDB来代替MySQL的InnoDB。<br>    <strong>SQLite</strong> 是一款轻型的数据库，遵守ACID的关系型数据库管理系统，包含在一个相对小的C库中。设计目标是嵌入式，它占用资源非常的低，在嵌入式设备中，可能只需几百K内存就够了。<br>    <strong>Access</strong> 是由微软发布的关系数据库管理系统。它结合了MicrosoftJet Database Engine和图形用户界面两项特点，是Microsoft Office的系统程序之一。<br>    <strong>PostgreSQL</strong> 是以加州大学伯克利分校计算机系开发的POSTGRES(现已更名为PostgreSQL)为基础的对象关系型数据库管理系统（ORDBMS）。<br>    <strong>SQL Server</strong> 同样是微软公司推出的一种关系型数据库系统。是一个可扩展的、高性能的、为分布式客户机/服务器计算所设计的数据库管理系统，实现了与WindowsNT的有机结合，提供了基于事务的企业级信息管理系统方案。<br>    <strong>Teradata</strong> 整体上是按Shared Nothing 架构体系进行组织的，他的定位就是大型数据仓库系统，定位比较高。<br>    <strong>Ingres</strong> 是比较早的数据库系统，开始于加利福尼亚大学柏克莱分校的一个研究项目，该项目开始于70年代早期，在80年代早期结束。从80年代中期，在Ingres基础上产生了很多商业数据库软件，包括Sybase、MicrosoftSQL Server、NonStop SQL、Informix 。<br>    <strong>Informix</strong> 是IBM公司出品的关系数据库管理系统（RDBMS）家族。作为一个集成解决方案，它被定位为作为IBM在线事务处理（OLTP）旗舰级数据服务系统。<br>    <strong>Sybase</strong> 美国Sybase公司研制的一种关系型数据库系统，是一种典型的UNIX或WindowsNT平台上客户机/服务器环境下的大型数据库系统。<br>    <strong>FoxPro</strong> 是一种功能强大的数据库，是当今最受欢迎的数据库管理软件之一。FoxPro数据库最初由美国Fox公司1988年推出，1992年Fox公司被Microsoft公司收购。<br>    <strong>Percona</strong>为MySQL数据库服务器进行了改进，在功能和性能上较MySQL有着很显著的提升。该版本提升了在高负载情况下的InnoDB的性能，为DBA提供一些非常有用的性能诊断工具。<br>    <strong>Cache</strong> 是美国Intersystems公司产品，后关系型数据库(Post Relational database)中的领头羊。Cache数据库在国外特别是医疗领域，在美国和欧洲的HIS系统(医疗卫生管理信息系统)中，所占的比例最大，医疗界首选。</p></blockquote><h1 id="三-非关系型数据库"><a href="#三-非关系型数据库" class="headerlink" title="三 非关系型数据库"></a>三 非关系型数据库</h1><p>非关系型里有key-value型的，也有做搜索的，还有做文档和图形和扩展式的。<br>常见的非关系数据库如下：</p><blockquote><p>   <strong>Redis</strong>     一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。<br>    <strong>Neo4 j 一个高性能的,NOSQL图形数据库，它将结构化数据存储在网络上而不是表中。它是一个嵌入式的、基于磁盘的、具备完全的事务特性的Java持久化引擎。    </strong>Ria k 一个分布式的存储文档型数据库。<br>    <strong>HBas e 一个分布式的、面向列的开源数据库，源于Fay Chang的Google论文“Bigtable：一个结构化数据的分布式存储系统”。HBase是Apache的Hadoop项目的子项目。    </strong>Flar e 由日本第二大SNS网站green.jp开发，支持scale，可动态添加或删除数据库服务节点。<br>    <strong>MongoDB</strong> 一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。<br>    <strong>Couchbase</strong>  CouchDB和Membase合并后的产品，先进的Cache系统，由C/C++开发。<br>    <strong>Memcached</strong>  一套分布式的高速缓存系统，由LiveJournal的Brad Fitzpatrick开发。<br>    <strong>DynamoDB</strong> 被设计成用来托管的NoSQL数据库服务、可预期的性能、可实现无缝扩展性和可靠性等核心问题。<br>    <strong>Hazelcast</strong> 一个开源的可嵌入式数据网格，可以把它看做是内存数据库，但与Redis有不同。<br>    <strong>Accumulo</strong> 一个基于Google’s BigTable的高扩展性存储数据库。采用java编写并且操作于HDFS系统上。</p></blockquote><pre><code>**Cassandra** 一套开源分布式NoSQL数据库系统。最初由Facebook开发，用于储存收件箱等简单格式数据，集GoogleBigTable的数据模型与Amazon Dynamo的完全分布式的架构于一身。**Cloundant** 省却维护人员在数据库管理、维护和调优方面的工作，而不需要考虑数据库管理以及后续随着数据量增长带来的扩展性问题。麻省理工的三位物理学家在寻找上帝粒子的科学实验中将CouchDB进行了大量定制和改进，从而形成了Cloudant。**DataStax** 基于开源的“NoSQL”数据库Apache Cassandra，将Cassandra与Hadoop进行了集成。**FlockDB**  一个存储图数据的分布式数据库，图数据库的存储对象是图论里面的图，而非图片。Twitter使用它来存储人与人之间的关系图。**MarkLogic**  企业级的NoSQL数据库。是一个集存储、管理、搜索JSON和XML文档和图形数据的multi-model NoSWL数据库。**Voldemort** 一个分布式键-值（Key-value）存储系统，是Amazon Dynamo的一个开源克隆。**Twemproxy** 引入代理层，可将后端的多台Redis或Memcached实例进行统一管理与分配，使应用程序只需要在Twemproxy上进行操作，而不用关心后面具体有多少个真实的 Redis 或 Memcached 存储。**CockroachDB**一款开源的分布式数据库，具有NoSQL对海量数据的存储管理能力，又保持了传统数据库支持的ACID和SQL等，还支持跨地域、去中心、高并发、多副本强一致和高可用等特性。**Elasticsearch** 一个接近实时的搜索平台，从索引这个文档到这个文档能够被搜索到只有一个轻微的延迟。**Azure Cosmos DB** 由Microsoft提供的全球分布式多模型数据库。</code></pre><h1 id="NewSQL-新技术"><a href="#NewSQL-新技术" class="headerlink" title="NewSQL 新技术"></a>NewSQL 新技术</h1><p>还有一些新出现的数据库，应对目的不同。</p><blockquote><p>   <strong>TiDB</strong> 是国内PingCAP团队开发的一个分布式SQL数据库，其灵感来自于Google的F1和Google spanner, TiDB支持包括传统RDBMS和NoSQL的特性。<br>    <strong>LMDB</strong> 全称是Lightning Memory-Mapped Database(快如闪电的内存映射数据库)，它的文件结构简单，包含一个数据文件和一个锁文件。<br>    <strong>NuoDB</strong> 针对云伸缩设计的关系型数据库。重新定义了关系型数据库技术，它是针对弹性云系统而非单机系统设计的，因此可以将其看作是一个多用户、弹性、按需的分布式关系型数据库管理系统。<br>    <strong>VoltDB</strong> 一个内存数据库，提供了 NoSQL 数据库的可伸缩性和传统关系数据库系统的 ACID 一致性。<br>    <strong>TokuDB</strong> 是TokuTek公司研发的新引擎，支持事务/MVCC，数据压缩功能一流，支持异步写入数据功能。索引结构采用fractal tree数据结构，是buffer tree的变种，写入性能优异，适合写多读少的场景。<br>    <strong>MemSQL</strong> 内存数据库，可以横跨多个商用节点（服务器）扩展MemSQL数据集。<br>    <strong>Spanner</strong> 是谷歌公司研发的、可扩展的、多版本、全球分布式、同步复制数据库。<br>    <strong>LevelDB</strong> 是google实现的一个开源且非常高效的键值对存储数据库。<br>    <strong>Clustrix</strong> 是一款分布式数据库系统，它既支持最简单的Key-Value格式，又兼容MySQL的功能，同时能非常简单通过添加新的节点来存储数十亿条数据。<br>    <strong>HybridDB</strong> 是面向在线事务（OLTP）和在线分析（OLAP）混合场景的关系型数据库。HybridDB采用一份数据存储来进行OLTP和OLAP处理，解决了以往需要把一份数据多次复制来分别进行业务交易和数据分析的问题。<br>    <strong>ScaleBase</strong> 是一款基于 MySQL 而构建的动态数据库集群，已针对云技术进行了优化。该解决方案可实现 MySQL 关系数据的完整性，能使您向外扩展到无限数量的用户、数据和事务。<br>    <strong>SequoiaDB</strong> 是一款支持SQL、高并发、实时性、分布式、可扩展、灵活存储的操作型NewSQL数据库，现已开源。<br>    <strong>Tokyo Cabinet(TC)</strong> 是日本人平林干雄开发的一款DBM数据库读写非常快。 </p></blockquote><h1 id="四-云源生数据库"><a href="#四-云源生数据库" class="headerlink" title="四 云源生数据库"></a>四 云源生数据库</h1><p>云时代诞生的新型数据库，目前还处在发展阶段。</p><blockquote><p>   <strong>Aurora</strong>  亚马逊推出的云原生数据库。<br>    <strong>PolarDB</strong> 阿里产品。<br>    <strong>CynosDB</strong> 腾讯产品。</p></blockquote><h1 id="五-结语"><a href="#五-结语" class="headerlink" title="五 结语 "></a>五 结语 </h1><p>数据库种类实在太多，在此只列举了一部分，当然，大部分人能用得到的就一部分。<br>看到这些数据库，感觉自己知识实在匮乏，对很多东西理解太简单，对新技术的领悟太浅显。<br>希望能在数据这块好好研究，毕竟未来可期。</p><h1 id="六-参考资源"><a href="#六-参考资源" class="headerlink" title="六 参考资源"></a>六 参考资源</h1><p>[1] <a href="https://db-engines.com/en/ranking" target="_blank" rel="noopener">数据库排名</a></p><p>[2] <a href="https://www.infoq.cn/article/cloud-native-data" target="_blank" rel="noopener">什么是“云原生”数据</a></p><p>[3] <a href="https://zhuanlan.zhihu.com/p/48725521" target="_blank" rel="noopener">阿里云数据库入选Gartner</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> It </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python Matplotlib 画图中文乱码解决</title>
      <link href="/title/2cca9645/"/>
      <url>/title/2cca9645/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/10/30/K5JrgP.md.png" alt="matplotlib"><br><a id="more"></a></p><p>用matplotlib画图出现中文符号乱码，东改改西改改都不对，实际是没找到中文字体，应对方法如下。</p><h1 id="1-找到宋体"><a href="#1-找到宋体" class="headerlink" title="1.找到宋体"></a>1.找到宋体</h1><p> 拷贝Window/Fonts/simhei.ttf 到 /usr/local/lib/python2.7(3.6)/dist-packages/matplotlib/mpl-data/fonts/ttf</p><h1 id="2-删除缓冲文件"><a href="#2-删除缓冲文件" class="headerlink" title="2.删除缓冲文件"></a>2.删除缓冲文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf ~/.cache/matplotlib</span><br></pre></td></tr></table></figure><h1 id="3-设置字体配置文件"><a href="#3-设置字体配置文件" class="headerlink" title="3.设置字体配置文件"></a>3.设置字体配置文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /usr/local/lib/python2.7(3.6)/dist-packages/matplotlib/mpl-data/matplotlibrc</span><br><span class="line">取消这三行注释并加入值:</span><br><span class="line"></span><br><span class="line">(1) font.family     : sans-serif</span><br><span class="line">(2) font.sans-serif : SimHei, (加入SimHei,原有的字体不动)</span><br><span class="line">(2) axes.unicode_minus  : False</span><br></pre></td></tr></table></figure><h1 id="4-命令行进入python并尝试导入"><a href="#4-命令行进入python并尝试导入" class="headerlink" title="4.命令行进入python并尝试导入"></a>4.命令行进入python并尝试导入</h1><p>(导入后要稍等字体刷新)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:~$ python</span><br><span class="line">shieber@Kew:~$ python</span><br><span class="line">Python 3.6.7 (default, Oct 22 2018, 11:32:17)</span><br><span class="line">[GCC 8.2.0] on linux</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; import matplotlib.pyplot as plt</span><br></pre></td></tr></table></figure></p><h1 id="5-针对python3"><a href="#5-针对python3" class="headerlink" title="5.针对python3"></a>5.针对python3</h1><p>和python2一样的操作</p><blockquote><p>拷贝字体 /usr/local/lib/python3.6/dist-packages/matplotlib/mpl-data/fonts/ttf</p></blockquote><blockquote><p>修改配置文件/usr/local/lib/python3.6/dist-packages/matplotlib/mpl-data/matplotlibrc</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> It </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Tex排版系统及其衍生系列产品的简介</title>
      <link href="/title/51414649/"/>
      <url>/title/51414649/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/10/30/K5J8c6.md.jpg" alt="Tex"><br><a id="more"></a></p><h1 id="一-什么是Tex？"><a href="#一-什么是Tex？" class="headerlink" title="一. 什么是Tex？"></a>一. 什么是Tex？</h1><p> 你用微软的Word写文档并转换为pdf，但是你觉得很不满意，尤其是涉及到数学公式录入时，Word的公式编辑器太慢而且符号查找费时费力，最后导出的pdf还是很丑。当然WPS也是一个选择，但是涉及到公式一样的很痛苦。你厌倦了这种情况，但又不得不这么做，似乎只有Word或WPS才是写文档的工具。但其实在Word还没诞生的时候就有人设计出了跨平台的文档排版利器。上世纪，计算机学界泰斗人物高德纳(<a href="https://baike.baidu.com/item/%E5%94%90%E7%BA%B3%E5%BE%B7%C2%B7%E5%85%8B%E5%8A%AA%E7%89%B9/1436781?fromtitle=%E9%AB%98%E5%BE%B7%E7%BA%B3&amp;fromid=2155233" target="_blank" rel="noopener">Donald E. Knuth</a>)应出版社要求对他六十年代的巨作《计算机编程艺术》<a href="比尔盖茨在本书的后面写到：“如果你能读懂整套书，请发邮件给我&quot;">^1</a> 出修订版，他感到以手工方式对原稿进行修改存在种种不便，于是便放下手头的工作，开始设计一套高质量的计算机排版系统。原先计划花半年时间来改进排版技术然后继续写作的高德纳教授，最后却整整耗费十年心血，终于研制成功了闻名于世的TeX系统。TeX是一种优秀的电子排版系统，编译生成的文件格式是DVI格式，可以使用其他工具转换为PDF格式。TeX及其各种衍生系统可以应对多种场景，排版论文，书籍，报刊，报告时毫无问题，排版所得产品美观而且省时。</p><h1 id="二-Tex的历史"><a href="#二-Tex的历史" class="headerlink" title="二. Tex的历史"></a>二. Tex的历史</h1><p>TeX 的名字是由大写的希腊字母“tec”(tau, epsilon,chi)组成。在希腊语中这个词的意思是“科技”和“艺术”，这也解释了它的发音。“T”和“E”就像在“technology”中的发音一样，而“x”的发音类似于苏格兰语单词“loch”或德语单词“ach”中的“ch”，也类似于西班牙语中的“j”或俄语中的“kh”。TeX 标志为TEX，这三个字母相靠得很近，而且中间的那个E有点儿下沉。但在无格式文件中，就写为TeX。</p><p> TeX的第一版于1978年面世。在经过了不断的改进后，1982年版的TeX是一个十分稳定的版本。从此以后，TeX没有较大的变动，只有很少部分的改进和错误修正。现在几乎所有的操作系统平台下，都有相应的TeX软件，而且用它们排版同一个文件得到的输出结果是相同的。TeX目前的版本是3.141592，很接近圆周率π。每有一新的版本，就会加上一个π的小数点后的数。所以我们已经知道下一版本的TeX是3.1415926，最终将收敛到π，这也代表了TeX不断追求完美的理想。</p><p> TeX的源程序是用Pascal写成的，原因是高德纳教授希望TeX尽可能方便地移植到其它的操作系统中去。当时Pascal是最适合于这一要求的编程语言。这使得TeX现在已经在几乎所有的计算机系统中得到实现。</p><h1 id="三-易混淆的TeX概念"><a href="#三-易混淆的TeX概念" class="headerlink" title="三. 易混淆的TeX概念"></a>三. 易混淆的TeX概念</h1><p> TeX里存在两个重要概念：文档格式和排版引擎。</p><p> TeX系统工作原理：排版引擎编译文档生成相应的DVI，再由其他程序生成PDF文档等，不同的引擎支持的文档格式不尽相同。</p><p> TeX系统直接学习使用较困难，且使用的是Plain Tex格式，编译生成DVI格式文档而不是PDF格式，所以就有人对TeX进行扩展(定义宏集：就是把一段段代码抽象为指令)，就得到了不同的排版引擎和文档格式。</p><p> 由于各种扩展多了，TeX家族里就出现了排版引擎和文档格式名称混淆的情况。要搞清楚的是，TeX排版系统是核心，是一种排版引擎，其他的各种实现都是基于TeX而改进的引擎。</p><p> TeX及其衍生排版系统编译的文档统称为tex文档，他们名字相同，千万不要混淆了。</p><ol><li>Tex文档格式</li></ol><hr><p> <strong>Plain TeX:</strong> 是Tex中的一个最基本的宏集合与TeX的基础语言构成的一种Tex文档格式(类似 .txt，.docx格式)，由Tex引擎编译，是高德纳教授开发TeX时使用的格式。</p><p> <strong>LaTeX:</strong> 是一种新的Tex文档格式，和Plain Tex不同。LaTeX由美国计算机学家莱斯利·兰伯特（Leslie Lamport）在上世纪80年代初期开发，使用方便。它充分发挥了由TeX所提供的强大功能，能在很短时间内生成高质量的产品。现在是科技界的标准格式。</p><p> <strong>AMS-LaTeX:</strong> 由Michael Spivak基于TeX开发的一种新Tex文档格式，由美国数学协会使用，许多数学期刊接受的论文就需要AMS-LaTeX格式。因为该格式加入了对许多数学符号及有关字体的支持，使得写数学方面的文档十分方便。</p><p> <strong>TeXinfo:</strong> 自由软件基金会(<a href="https://www.fsf.org/" target="_blank" rel="noopener">FSF</a>)开发的一种Tex文档格式，是Linux等系统下的标准文档格式。</p><p> <strong>ConTeXt:</strong> 由Hans Hagen开发的一种Tex文档格式，编译后得到漂亮的出版样式。</p><ol start="2"><li>Tex的各种排版引擎和指令</li></ol><hr><p> <strong>TeX:</strong> 最初由高德纳发明的一种排版引擎，编译Plain TeX格式的文档。</p><p> <strong>MikTex:</strong> 是Windows平台下的一种Tex的实现，一种排版引擎，已经被包含到CTeX套件中。</p><p> <strong>CTeX:</strong> 最初是由中科院数学与系统科学研究院的<a href="http://sourcedb.amss.cas.cn/zw/zjrck/yjy/200910/t20091016_2552703.html" target="_blank" rel="noopener">吴凌云</a>研究员制作发布的TeX套装，是CTeX中文套装的简称。基于MikTex引擎的Windows实现。CTeX是把MikTeX，WinEdit，GSview，Ghostscript等一些常用的相关工具包装在一起制作的一个简易安装程序，并对其中文支持部分进行了配置，安装后就可以使用中文。因为CTeX结合图形界面并包含编辑器和文档查看工具，所以使用非常方便，特殊符号还可以点击插入，很多Windows下的专业人员就使用该套装处理文档。我本人的本科毕业论文就是用CTeX做的。</p><p> <strong>cwTeX:</strong> 是由台湾同胞吴聪敏和吴聪慧制作发布的跨平台TeX套装，和CTeX类似，只是台湾人用的多，支持繁体字，编译的文档格式是.ctx。</p><p> <strong>proTeXt:</strong> 是Windows下的一款基于MikTeX的简易安装发行版TeX排版系统。</p><p> <strong>MacTeX:</strong> 是Mac OSX下的TeX实现，一种排版引擎，用苹果电脑的用户首选。</p><p> <strong>Tex Live:</strong> 是美国数学学会创立的TUG(TeX User Group)维护和发布的一种基于TeX的排版引擎，跨平台(Windows,Unix/Linux,Mac OSX)。</p><p> <strong>PDFTex:</strong> 也是TeX的一种实现，一种排版引擎，可以把Tex原始文档直接转换为PDF文档。</p><p> <strong>Tex:</strong> 是PDFTeX引擎的指令，用于将Plain TeX格式文档生成DVI文档，容易和TeX引擎搞混。</p><p> <strong>LaTex:</strong> 是PDFTeX引擎的指令，用于将LaTeX格式文档生成DVI文档，容易和LaTeX文档格式搞混。</p><p> <strong>PDFtex:</strong> 是PDFTeX引擎的指令，用于编译Plain Tex格式文档生成PDF文档。</p><p> <strong>PDFLaTex:</strong> 是PDFTeX引擎的指令，用于编译LaTex格式文档生成PDF文档。</p><p> <strong>XeTeX:</strong> 是TeX的一种实现，一种排版引擎，支持Unicode和操作系统字体。</p><p> <strong>Xetex:</strong> 是XeTeX引擎的指令，用来编译Plain TeX文档生成PDF文档。</p><p> <strong>XeLaTex:</strong> 是XeTeX引擎的指令，用来编译LaTex格式文档生成PDF文档。</p><p> <strong>LuaTeX:</strong> 新的TeX实现，一种新的引擎，正在不断完善。</p><p> <strong>Luatex:</strong> 是LuaTeX引擎的指令，用于将Plaint TeX格式文档编译成PDF文档。</p><p> <strong>LuaLaTex:</strong> 是LuaTeX引擎的指令，用于将LaTeX格式文档编译成PDF文档。</p><p> <strong>context:</strong> 是LuaTeX引擎的指令，用于将ConTeXt格式文档编译成PDF文档。</p><ol start="3"><li>Tex文档的编辑器和有关工具</li></ol><hr><p> <strong>GSview:</strong> CTeX套装包含的文档查看器，可以直接查看PostScript文档和PDF文档。</p><p> <strong>Ghostscript:</strong> 是一种PostScript的解释器，可以用来查看PostScript和PDF文档。</p><p> <strong>WinEdit:</strong> 是CTeX套装的编辑器，就是写Tex文档的工具。</p><p> <strong>TeXShop:</strong> 是MacTeX下的一款Tex文档编辑器，界面美观，苹果永远追求美的享受啊!</p><p> <strong>TeXWorks:</strong> 是TexLive自带的Tex文档编辑器，由XeTeX作者Jonathan Kew仿照Mac上的TeXShop写出。</p><p> <strong>TeXMaker:</strong> 另一款Tex文档编辑器，支持文档导航。</p><p> <strong>TeXStudio:</strong> 又一款Tex文档编辑器，衍生自TeXmaker，功能更为强大。</p><p> 由于我们要处理中文，<strong>推荐使用LuaTeX和XeLaTex两个引擎来排版</strong>，尤其是在CTeX套装中，选择这两个引擎可以解决中文编译问题。编辑器<strong>推荐TexStutio</strong>，当然，这个要难一些，但是学会了工作称心。</p><h1 id="四-TeX的优点"><a href="#四-TeX的优点" class="headerlink" title="四. TeX的优点"></a>四. TeX的优点</h1><p> TeX特别适合于科技论文和书籍的排版，利用它可以在计算机上生成与印刷品几乎完全一样的作品，目前在国外已经被广泛地用于编排书籍、档案、学位论文和私人信件，以及各种复杂的公式、目录、索引和参考文献等。由于使用TeX可以很轻松地完成高质量科技文献的排版工作，并且可以按照作者的要求进行扩充和修改，所以逐渐引起出版界和各国科技工作者的注意，被一致认为是目前国际上排版数学公式能力最强的系统，并且在各种国际会议上被指定为标准的论文编排软件。</p><p> 稍有经验的人都会知道，即使再好的字处理软件打印出来的效果也都会跟屏幕上看到的有所差异，尤其是Word，还记得拿到打印店时格式出错，字迹变样吗？而TeX系统的输出是与设备无关的DVI（DeVice Independent）文件，因此无论是在针式打印机、喷墨打印机、激光打印机或是照排机上，其效果都是完全相同的，仅仅只是文字或者图形的分辩率因设备的不同而稍有差异。从这种意义上说，TeX才是真正的”所见即所得(What you see is what you get)”。</p><h1 id="五-Tex的各种资源和站点"><a href="#五-Tex的各种资源和站点" class="headerlink" title="五. Tex的各种资源和站点"></a>五. Tex的各种资源和站点</h1><p>(1) <a href="http://www.ctex.org/CTeXDownload/" target="_blank" rel="noopener">CTeX 套装官网</a><br>(2) <a href="https://www.latex-project.org/" target="_blank" rel="noopener">LaTeX项目官网</a><br>(3) <a href="http://tug.org/texlive/" target="_blank" rel="noopener">TeXLive的官网</a><br>(4) <a href="https://ctan.org/" target="_blank" rel="noopener">CTAN 宏包官网</a></p>]]></content>
      
      
      <categories>
          
          <category> 排版设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> It </tag>
            
            <tag> Tex </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>各种编程语言的适用范围</title>
      <link href="/title/45b4e77f/"/>
      <url>/title/45b4e77f/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/10/30/K5JKAJ.md.jpg" alt="Lang"><br><a id="more"></a></p><p>自Fortran语言诞生至今，各种计算机编程语言总和超过1500种，但今天还流行的并不多。大部分人在初学编程时都会问：”我该学什么语言？”。语言没有明显优劣，只有适合还是不适合，擅长与否，有的语言就是要比其他语言更适合某个领域。本文旨在梳理<a href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="noopener">TIOBE</a><br>榜(The Importance Of Being<br>Earnest)上一部分语言的适用场景，希望能成为一份粗略的编程语言选择指南。(排名没有先后)</p><h1 id="TIOBE-Index收录的计算机语言的适用范围"><a href="#TIOBE-Index收录的计算机语言的适用范围" class="headerlink" title="TIOBE Index收录的计算机语言的适用范围"></a>TIOBE Index收录的计算机语言的适用范围</h1><p><strong>Tex</strong><br>(1) 这个似乎不是编程语言，但是对于一心追求美的人来说是不可少的。<br>(2) 适用于书籍，报刊，杂志，论文，报告等等文档的排版。<br>(3) 详细内容请看另一篇博文<a href="https://blog.csdn.net/Shieber/article/details/88556859" target="_blank" rel="noopener">Tex排版系统及其衍生系列产品的简介</a>  </p><p><strong>Java</strong><br>(1) 桌面应用，Web应用<br>(2) 企业级应用，安卓应用<br>(3) 软件工具，交易程序<br>(4) 大数据和科学应用 </p><p><strong>C</strong><br>(1) 类Unix操作系统，嵌入式<br>(2) 交换机，路由器，防火墙<br>(3) 驱动程序，航空飞行器<br>(4) 工程控制领域，机器人<br>(5) 木马，病毒 </p><p><strong>C++</strong><br>(1) 游戏引擎，服务器<br>(2) 图像处理，虚拟现实<br>(3) 音视频处理，压缩技术<br>(4) 数据库，安全协议<br>(5) 图形用户界面，网络<br>(6) 科学计算，人工智能<br>(7) 编译器，调试器<br>(8) 木马，病毒  </p><p><strong>Python</strong><br>(1) 网络爬虫，人工智能<br>(2) 科学计算，Web开发<br>(3) 大数据，云计算<br>(4) 量化金融，运维<br>(5) 图像，音视频处理<br>(6) 木马，病毒  </p><p><strong>Ruby</strong><br>(1) Web开发 </p><p><strong>Perl</strong><br>(1) Unix系统维护，CGI脚本<br>(2) 邮件文本处理和FTP自动化<br>(3) 数据库通信，Web站点维护自动化  </p><p><strong>R</strong><br>(1) 数据挖掘，统计分析<br>(2) 生物医学领域<br>(3) 自动化报告  </p><p><strong>JavaScript</strong><br>(1) 网站前端，Web应用<br>(2) 网站后端，插件开发</p><p><strong>HTML</strong><br>(1) 这不是一门编程语言<br>(2) 网页生成<br>(3) 电子书制作</p><p><strong>PHP</strong><br>(1) 网站开发，电子商务<br>(2) Web应用，企业级应用<br>(3) 微信开发，客户端界面  </p><p><strong>Go</strong><br>(1) 服务器，数据库<br>(2) 分布式大型系统，云平台</p><p><strong>Kotlin</strong><br>(1) 安卓官方开发语言</p><p><strong>Swift</strong><br>(1) IOS及OS X开发</p><p><strong>C#</strong><br>(1) Windows桌面应用，Web 应用</p><p><strong>Objective-C</strong><br>(1) IOS平台软件开发</p><p><strong>Bash</strong><br>(1) 自动化脚本</p><p><strong>SQL</strong><br>(1) 数据库</p><p><strong>Visual Basic.NET</strong><br>(1) 可视化程序设计<br>(2) 木马，病毒</p><p><strong>MATLAB</strong><br>(1) 科学计算，仿真模拟<br>(2) 人工智能</p><p><strong>Assembly</strong><br>(1) 底层，硬件控制<br>(2) 木马，病毒</p><p><strong>Groovy</strong><br>(1) Java的替代品</p><p><strong>Delphi</strong><br>(1) 桌面开发，数据库开发<br>(2) Web服务，游戏控制软件<br>(3) 木马，病毒</p><p><strong>Pascal</strong><br>(1) 编程竞赛，算法研究</p><p><strong>Fortran</strong><br>(1) 科学研究，物理</p><p><strong>Lua</strong><br>(1) 游戏脚本，内嵌脚本</p><p><strong>Julia</strong><br>(1) 科学计算</p><p><strong>TypeScript</strong><br>(1) 应用级的JavaScript开发语言</p><p><strong>Lisp</strong><br>(1) 人工智能</p><p><strong>Rust</strong><br>(1) 系统级编程</p><p><strong>PostCript</strong><br>(1) 印刷机，打印机使用</p><p><strong>Dart</strong><br>(1) Web，服务器<br>(2) 物联网</p><p><strong>Scratch</strong><br>(1) 儿童的编程语言</p><p><strong>COBOL</strong><br>(1) 银行(四大行），保险，金融行业</p><p><strong>Scala</strong><br>(1) 大数据，Web服务</p><p><strong>Scheme</strong><br>(1) 科学计算</p><p><strong>Haskell</strong><br>(1) 函数式编程</p><p><strong>PowerShell</strong><br>(1) 自动化脚本，调用.Net和COM对象</p><p><strong>Awk</strong><br>(1) 字节流数据处理</p><p><strong>Erlang</strong><br>(1) 游戏网页，高并发</p><p><strong>Clojure</strong><br>(1) 游戏后端<br>(2) 自动化测试，黑盒测试  </p><p><strong>Maple</strong><br>(1) 数值计算</p><p><strong>VHDL</strong><br>(1) 电路设计</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>一般人用得到的语言估计就这些了，每门语言的的适用领域不一定写全，但是大体不会错误，你用过多少种语言？</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> It </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL 官方推荐数据库连接器 Connector 8.0</title>
      <link href="/title/925b0210/"/>
      <url>/title/925b0210/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/10/30/K5Go0e.jpg" alt="Mysql">　<br><a id="more"></a></p><h1 id="一-python-connector-8-0-简介"><a href="#一-python-connector-8-0-简介" class="headerlink" title="一. python connector 8.0 简介"></a>一. python connector 8.0 简介</h1><p>MySQL Connector/Python 8.0(以下简称Connector)是一个自完备的Python驱动器，实现了同MySQL server的连接，是MySQL官方高度推荐使用的连接器，而MySQLdb则不是。该连接器符合Python的数据库API标准2.0(PEP 249)标准，纯Python写成，只依赖Python标准库。如果有需要，请尽量使用Connector。当然，其他语言的Connector实现也有，包括C，C++，NET，ODBC，J。本文只针对Python。</p><h1 id="二-connector的变化"><a href="#二-connector的变化" class="headerlink" title="二. connector的变化"></a>二. connector的变化</h1><p>MySQL Connector/Python 支持：<br>(1) 几乎所有数据库特性，包括5.7版本的。<br>(2) 支持X DevAPI。<br>(3) All MySQL extensions to standard SQL syntax。<br>(4) 数据流压缩，实现客户端到服务器端的高效沟通。<br>(5) 使用SSL的TCP/IP套接字，在类Unix上使用Unix套接字。<br>(6) 支持数据类型在MySQL和Python间的转换。<br>例如Python的datetime和MySQL的DATETIME间相互转换，并且可以自由设置是否开启转换。  </p><h1 id="三-各个版本支持的MySQL和Python版本"><a href="#三-各个版本支持的MySQL和Python版本" class="headerlink" title="三. 各个版本支持的MySQL和Python版本"></a>三. 各个版本支持的MySQL和Python版本</h1><table><thead><tr><th style="text-align:center">Connector Version</th><th style="text-align:center">MySQL Server Versions</th><th style="text-align:center">Python Versions</th></tr></thead><tbody><tr><td style="text-align:center">     8.0</td><td style="text-align:center">8.0, 5.7, 5.6, 5.5</td><td style="text-align:center">3.7, 3.6, 3.5, 3.4, 2.7     </td></tr><tr><td style="text-align:center">     2.1</td><td style="text-align:center">5.7, 5.6, 5.5</td><td style="text-align:center">3.5, 3.4, 2.7, 2.6     </td></tr><tr><td style="text-align:center">     2.0</td><td style="text-align:center">5.7, 5.6, 5.5</td><td style="text-align:center">3.5, 3.4, 2.7, 2.6 </td></tr><tr><td style="text-align:center">     1.2</td><td style="text-align:center">5.7, 5.6, 5.5 5.1, 5.0, 4.1</td><td style="text-align:center">3.4, 3.3, 3.2, 3.1, 2.7, 2.6 </td></tr></tbody></table><h1 id="四-安装"><a href="#四-安装" class="headerlink" title="四. 安装"></a>四. 安装</h1><ol><li>Linux下</li></ol><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip install mysql-connector-python</span><br></pre></td></tr></table></figure><ol start="2"><li>Windows下</li></ol><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install mysql-connector-python</span><br></pre></td></tr></table></figure><h1 id="五-连接方式"><a href="#五-连接方式" class="headerlink" title="五. 连接方式"></a>五. 连接方式</h1><ol><li>连接方式1</li></ol><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import mysql.connector</span><br><span class="line">cnx = mysql.connector.connect(user=&apos;scott&apos;, </span><br><span class="line">                              password=&apos;password&apos;,</span><br><span class="line">                              host=&apos;127.0.0.1&apos;,</span><br><span class="line">                              database=&apos;employees&apos;)</span><br><span class="line">cnx.close()</span><br></pre></td></tr></table></figure><ol start="2"><li>连接方式2</li></ol><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from mysql.connector import (connection)</span><br><span class="line">cnx = connection.MySQLConnection(user=&apos;scott&apos;,</span><br><span class="line">                                 password=&apos;password&apos;,</span><br><span class="line">                                 host=&apos;127.0.0.1&apos;,</span><br><span class="line">                                 database=&apos;employees&apos;)</span><br><span class="line">cnx.close()</span><br></pre></td></tr></table></figure><p>常用的是连接方式1</p><ol start="3"><li>错误处理</li></ol><hr><p>为了应对连接错误，可以引入try-except机制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import mysql.connector</span><br><span class="line">from mysql.connector import errorcode</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">cnx = mysql.connector.connect(user=&apos;scott&apos;, database=&apos;employ&apos;)</span><br><span class="line">except mysql.connector.Error as err:</span><br><span class="line">if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:</span><br><span class="line">    print(&quot;Something is wrong with your user name or password&quot;)</span><br><span class="line">elif err.errno == errorcode.ER_BAD_DB_ERROR:</span><br><span class="line">print(&quot;Database does not exist&quot;)</span><br><span class="line">  else:</span><br><span class="line">    print(err)</span><br><span class="line">else:</span><br><span class="line">cnx.close()</span><br></pre></td></tr></table></figure></p><ol start="4"><li>把参数单独放到外面或者文件中</li></ol><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import mysql.connector</span><br><span class="line"></span><br><span class="line">config = &#123;</span><br><span class="line">  &apos;user&apos;: &apos;scott&apos;,</span><br><span class="line">  &apos;password&apos;: &apos;password&apos;,</span><br><span class="line">  &apos;host&apos;: &apos;127.0.0.1&apos;,</span><br><span class="line">  &apos;database&apos;: &apos;employees&apos;,</span><br><span class="line">  &apos;raise_on_warnings&apos;: True</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cnx = mysql.connector.connect(**config)</span><br><span class="line">cnx.close()</span><br></pre></td></tr></table></figure><h1 id="五-常见使用形式"><a href="#五-常见使用形式" class="headerlink" title="五.常见使用形式"></a>五.常见使用形式</h1><h2 id="0-连接器操作原理"><a href="#0-连接器操作原理" class="headerlink" title="0.连接器操作原理"></a>0.连接器操作原理</h2><p><strong>Connector的工作流程：</strong><br>(1) 接到数据库。<br>(2) 返回一个游标连接对象。<br>(3) 通过游标对数据库执行增删查改操作。<br>(4) 操作完成，分别断开连接。 </p><p><strong>具体示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cnx = mysql.connector.connect(database=&apos;world&apos;)</span><br><span class="line">cursor = cnx.cursor()</span><br><span class="line">cursor.execute(&apos;SQL语句&apos;)</span><br><span class="line">cursor.close()</span><br><span class="line">cnx.close()</span><br></pre></td></tr></table></figure><h2 id="1-创建表"><a href="#1-创建表" class="headerlink" title="1.创建表"></a>1.创建表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">from __future__ import print_function</span><br><span class="line"></span><br><span class="line">import mysql.connector</span><br><span class="line">from mysql.connector import errorcode</span><br><span class="line"></span><br><span class="line">DB_NAME = &apos;employees&apos;</span><br><span class="line"></span><br><span class="line">TABLES = &#123;&#125;</span><br><span class="line">TABLES[&apos;employees&apos;] = (</span><br><span class="line">    &quot;CREATE TABLE `employees` (&quot;</span><br><span class="line">    &quot;  `emp_no` int(11) NOT NULL AUTO_INCREMENT,&quot;</span><br><span class="line">    &quot;  `birth_date` date NOT NULL,&quot;</span><br><span class="line">    &quot;  `first_name` varchar(14) NOT NULL,&quot;</span><br><span class="line">    &quot;  `last_name` varchar(16) NOT NULL,&quot;</span><br><span class="line">    &quot;  `gender` enum(&apos;M&apos;,&apos;F&apos;) NOT NULL,&quot;</span><br><span class="line">    &quot;  `hire_date` date NOT NULL,&quot;</span><br><span class="line">    &quot;  PRIMARY KEY (`emp_no`)&quot;</span><br><span class="line">    &quot;) ENGINE=InnoDB&quot;)</span><br><span class="line"></span><br><span class="line">TABLES[&apos;departments&apos;] = (</span><br><span class="line">    &quot;CREATE TABLE `departments` (&quot;</span><br><span class="line">    &quot;  `dept_no` char(4) NOT NULL,&quot;</span><br><span class="line">    &quot;  `dept_name` varchar(40) NOT NULL,&quot;</span><br><span class="line">    &quot;  PRIMARY KEY (`dept_no`), UNIQUE KEY `dept_name` (`dept_name`)&quot;</span><br><span class="line">    &quot;) ENGINE=InnoDB&quot;)</span><br><span class="line"></span><br><span class="line">TABLES[&apos;salaries&apos;] = (</span><br><span class="line">    &quot;CREATE TABLE `salaries` (&quot;</span><br><span class="line">    &quot;  `emp_no` int(11) NOT NULL,&quot;</span><br><span class="line">    &quot;  `salary` int(11) NOT NULL,&quot;</span><br><span class="line">    &quot;  `from_date` date NOT NULL,&quot;</span><br><span class="line">    &quot;  `to_date` date NOT NULL,&quot;</span><br><span class="line">    &quot;  PRIMARY KEY (`emp_no`,`from_date`), KEY `emp_no` (`emp_no`),&quot;</span><br><span class="line">    &quot;  CONSTRAINT `salaries_ibfk_1` FOREIGN KEY (`emp_no`) &quot;</span><br><span class="line">    &quot;     REFERENCES `employees` (`emp_no`) ON DELETE CASCADE&quot;</span><br><span class="line">    &quot;) ENGINE=InnoDB&quot;)</span><br><span class="line"></span><br><span class="line">TABLES[&apos;dept_emp&apos;] = (</span><br><span class="line">    &quot;CREATE TABLE `dept_emp` (&quot;</span><br><span class="line">    &quot;  `emp_no` int(11) NOT NULL,&quot;</span><br><span class="line">    &quot;  `dept_no` char(4) NOT NULL,&quot;</span><br><span class="line">    &quot;  `from_date` date NOT NULL,&quot;</span><br><span class="line">    &quot;  `to_date` date NOT NULL,&quot;</span><br><span class="line">    &quot;  PRIMARY KEY (`emp_no`,`dept_no`), KEY `emp_no` (`emp_no`),&quot;</span><br><span class="line">    &quot;  KEY `dept_no` (`dept_no`),&quot;</span><br><span class="line">    &quot;  CONSTRAINT `dept_emp_ibfk_1` FOREIGN KEY (`emp_no`) &quot;</span><br><span class="line">    &quot;     REFERENCES `employees` (`emp_no`) ON DELETE CASCADE,&quot;</span><br><span class="line">    &quot;  CONSTRAINT `dept_emp_ibfk_2` FOREIGN KEY (`dept_no`) &quot;</span><br><span class="line">    &quot;     REFERENCES `departments` (`dept_no`) ON DELETE CASCADE&quot;</span><br><span class="line">    &quot;) ENGINE=InnoDB&quot;)</span><br><span class="line"></span><br><span class="line">TABLES[&apos;dept_manager&apos;] = (</span><br><span class="line">    &quot;  CREATE TABLE `dept_manager` (&quot;</span><br><span class="line">    &quot;  `dept_no` char(4) NOT NULL,&quot;</span><br><span class="line">    &quot;  `emp_no` int(11) NOT NULL,&quot;</span><br><span class="line">    &quot;  `from_date` date NOT NULL,&quot;</span><br><span class="line">    &quot;  `to_date` date NOT NULL,&quot;</span><br><span class="line">    &quot;  PRIMARY KEY (`emp_no`,`dept_no`),&quot;</span><br><span class="line">    &quot;  KEY `emp_no` (`emp_no`),&quot;</span><br><span class="line">    &quot;  KEY `dept_no` (`dept_no`),&quot;</span><br><span class="line">    &quot;  CONSTRAINT `dept_manager_ibfk_1` FOREIGN KEY (`emp_no`) &quot;</span><br><span class="line">    &quot;     REFERENCES `employees` (`emp_no`) ON DELETE CASCADE,&quot;</span><br><span class="line">    &quot;  CONSTRAINT `dept_manager_ibfk_2` FOREIGN KEY (`dept_no`) &quot;</span><br><span class="line">    &quot;     REFERENCES `departments` (`dept_no`) ON DELETE CASCADE&quot;</span><br><span class="line">    &quot;) ENGINE=InnoDB&quot;)</span><br><span class="line"></span><br><span class="line">TABLES[&apos;titles&apos;] = (</span><br><span class="line">    &quot;CREATE TABLE `titles` (&quot;</span><br><span class="line">    &quot;  `emp_no` int(11) NOT NULL,&quot;</span><br><span class="line">    &quot;  `title` varchar(50) NOT NULL,&quot;</span><br><span class="line">    &quot;  `from_date` date NOT NULL,&quot;</span><br><span class="line">    &quot;  `to_date` date DEFAULT NULL,&quot;</span><br><span class="line">    &quot;  PRIMARY KEY (`emp_no`,`title`,`from_date`), KEY `emp_no` (`emp_no`),&quot;</span><br><span class="line">    &quot;  CONSTRAINT `titles_ibfk_1` FOREIGN KEY (`emp_no`)&quot;</span><br><span class="line">    &quot;     REFERENCES `employees` (`emp_no`) ON DELETE CASCADE&quot;</span><br><span class="line">    &quot;) ENGINE=InnoDB&quot;)</span><br><span class="line"></span><br><span class="line">cnx = mysql.connector.connect(user=&apos;scott&apos;)</span><br><span class="line">cursor = cnx.cursor()</span><br><span class="line"></span><br><span class="line">def create_database(cursor):</span><br><span class="line">    try:</span><br><span class="line">        cursor.execute(</span><br><span class="line">            &quot;CREATE DATABASE &#123;&#125; DEFAULT CHARACTER SET &apos;utf8&apos;&quot;.format(DB_NAME))</span><br><span class="line">    except mysql.connector.Error as err:</span><br><span class="line">        print(&quot;Failed creating database: &#123;&#125;&quot;.format(err))</span><br><span class="line">        exit(1)</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    cursor.execute(&quot;USE &#123;&#125;&quot;.format(DB_NAME))</span><br><span class="line">except mysql.connector.Error as err:</span><br><span class="line">    print(&quot;Database &#123;&#125; does not exists.&quot;.format(DB_NAME))</span><br><span class="line">    if err.errno == errorcode.ER_BAD_DB_ERROR:</span><br><span class="line">        create_database(cursor)</span><br><span class="line">        print(&quot;Database &#123;&#125; created successfully.&quot;.format(DB_NAME))</span><br><span class="line">        cnx.database = DB_NAME</span><br><span class="line">    else:</span><br><span class="line">        print(err)</span><br><span class="line">        exit(1)</span><br><span class="line"></span><br><span class="line">for table_name in TABLES:</span><br><span class="line">    table_description = TABLES[table_name]</span><br><span class="line">    try:</span><br><span class="line">        print(&quot;Creating table &#123;&#125;: &quot;.format(table_name), end=&apos;&apos;)</span><br><span class="line">        cursor.execute(table_description)</span><br><span class="line">    except mysql.connector.Error as err:</span><br><span class="line">        if err.errno == errorcode.ER_TABLE_EXISTS_ERROR:</span><br><span class="line">            print(&quot;already exists.&quot;)</span><br><span class="line">        else:</span><br><span class="line">            print(err.msg)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;OK&quot;)</span><br><span class="line"></span><br><span class="line">cursor.close()</span><br><span class="line">cnx.close()</span><br></pre></td></tr></table></figure><h2 id="2-插入"><a href="#2-插入" class="headerlink" title="2.插入"></a>2.插入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">from __future__ import print_function</span><br><span class="line">from datetime import date, datetime, timedelta</span><br><span class="line">import mysql.connector</span><br><span class="line"></span><br><span class="line">cnx = mysql.connector.connect(user=&apos;scott&apos;, database=&apos;employees&apos;)</span><br><span class="line">cursor = cnx.cursor()</span><br><span class="line"></span><br><span class="line">tomorrow = datetime.now().date() + timedelta(days=1)</span><br><span class="line"></span><br><span class="line">add_employee = (&quot;INSERT INTO employees &quot;</span><br><span class="line">               &quot;(first_name, last_name, hire_date, gender, birth_date) &quot;</span><br><span class="line">               &quot;VALUES (%s, %s, %s, %s, %s)&quot;)</span><br><span class="line">add_salary = (&quot;INSERT INTO salaries &quot;</span><br><span class="line">              &quot;(emp_no, salary, from_date, to_date) &quot;</span><br><span class="line">              &quot;VALUES (%(emp_no)s, %(salary)s, %(from_date)s, %(to_date)s)&quot;)</span><br><span class="line"></span><br><span class="line">data_employee = (&apos;Geert&apos;, &apos;Vanderkelen&apos;, tomorrow, &apos;M&apos;, date(1977, 6, 14))</span><br><span class="line"></span><br><span class="line"># Insert new employee</span><br><span class="line">cursor.execute(add_employee, data_employee)</span><br><span class="line">emp_no = cursor.lastrowid</span><br><span class="line"></span><br><span class="line"># Insert salary information</span><br><span class="line">data_salary = &#123;</span><br><span class="line">  &apos;emp_no&apos;: emp_no,</span><br><span class="line">  &apos;salary&apos;: 50000,</span><br><span class="line">  &apos;from_date&apos;: tomorrow,</span><br><span class="line">  &apos;to_date&apos;: date(9999, 1, 1),</span><br><span class="line">&#125;</span><br><span class="line">cursor.execute(add_salary, data_salary)</span><br><span class="line"></span><br><span class="line">cnx.commit() #只是查询时，不需这行，涉及修改数据则必须</span><br><span class="line"></span><br><span class="line">cursor.close()</span><br><span class="line">cnx.close()</span><br></pre></td></tr></table></figure><h2 id="3-查询"><a href="#3-查询" class="headerlink" title="3.查询"></a>3.查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import datetime</span><br><span class="line">import mysql.connector</span><br><span class="line"></span><br><span class="line">cnx = mysql.connector.connect(user=&apos;scott&apos;, database=&apos;employees&apos;)</span><br><span class="line">cursor = cnx.cursor()</span><br><span class="line"></span><br><span class="line">query = (&quot;SELECT first_name, last_name, hire_date FROM employees &quot;</span><br><span class="line">         &quot;WHERE hire_date BETWEEN %s AND %s&quot;)</span><br><span class="line"></span><br><span class="line">hire_start = datetime.date(1999, 1, 1)</span><br><span class="line">hire_end = datetime.date(1999, 12, 31)</span><br><span class="line"></span><br><span class="line">cursor.execute(query, (hire_start, hire_end))</span><br><span class="line"></span><br><span class="line">for (first_name, last_name, hire_date) in cursor:</span><br><span class="line">  print(&quot;&#123;&#125;, &#123;&#125; was hired on &#123;:%d %b %Y&#125;&quot;.format(</span><br><span class="line">    last_name, first_name, hire_date))</span><br><span class="line"></span><br><span class="line">cursor.close()</span><br><span class="line">cnx.close()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL 8.0 迁移数据存储位置到指定位置(Linux版)</title>
      <link href="/title/dd137b08/"/>
      <url>/title/dd137b08/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/10/30/K5Go0e.jpg" alt="Mysql">　<br><a id="more"></a></p><h1 id="一：具体步骤"><a href="#一：具体步骤" class="headerlink" title="一：具体步骤"></a>一：具体步骤</h1><p><strong>停止mysql服务</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service mysql stop</span><br></pre></td></tr></table></figure></p><p><strong>拷贝数据存储到你的新位置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例如: /home/database/</span><br><span class="line">$ sudo cp -R /var/lib/mysql /home/database/</span><br></pre></td></tr></table></figure><p><strong>打开/etc/mysql/mysql.conf.d/mysqld.cnf修改数据存储位置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">将以下两行注释掉并加入新的两行(按自己的位置修改)</span><br><span class="line">\#socket = /var/run/mysqld/mysqld.sock</span><br><span class="line">\#datadir= /var/lib/mysql</span><br><span class="line">socket = /home/database/mysql/mysql.sock</span><br><span class="line">datadir = /home/database/mysql</span><br><span class="line">再接着添加以下内容</span><br><span class="line">[client]</span><br><span class="line">socket = /home/database/mysql/mysql.sock</span><br><span class="line">[mysql]</span><br><span class="line"> socket = /home/database/mysql/mysql.sock</span><br></pre></td></tr></table></figure><p><strong>打开/etc/apparmor.d/usr.sbin.mysqld修改新位置的读写权限</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注释以下两行并加入新的两行（用gedit修改该文件要记得删除可能存在的usr.sbin.mysqld~ 文件，不然启动会失败）</span><br><span class="line">\#/var/lib/mysql/ r,</span><br><span class="line">\#/var/lib/mysql/\*\* rwk,</span><br><span class="line">/home/database/mysql/ r,</span><br><span class="line">/home/database/mysql/\*\* rwk,</span><br></pre></td></tr></table></figure></p><p><strong>打开/etc/apparmor.d/abstractions/mysql修改数据库的依赖路径</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注释下面一行并加入第三行(这是个大坑)</span><br><span class="line">\#/var/lib/mysql&#123;,d&#125;/mysql&#123;,d&#125;.sock rw,</span><br><span class="line">/home/database/mysql/mysql.sock rw,</span><br></pre></td></tr></table></figure></p><p><strong>重新加载apparmor刷新配置文件</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo /etc/init.d/apparmor reload</span><br></pre></td></tr></table></figure></p><p><strong>重新加载mysql服务</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service mysql start</span><br></pre></td></tr></table></figure></p><h1 id="二：其他几个大坑可能导致启动失败"><a href="#二：其他几个大坑可能导致启动失败" class="headerlink" title="二：其他几个大坑可能导致启动失败"></a>二：其他几个大坑可能导致启动失败</h1><p><strong>mysql/的权限属性</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">注意查看/home/database/mysql是否属于mysql组和mysql用户，及权限，若不是则执行</span><br><span class="line">$ sudo chown -R mysql:mysql /home/database/mysql</span><br><span class="line">$ sudo chmod 755 /home/database/mysql/</span><br><span class="line">没有mysql组的通过以下命令创建mysql组和用户</span><br><span class="line">$ sudo groupadd mysql</span><br><span class="line">$ sudo useradd -r -g mysql mysql</span><br></pre></td></tr></table></figure></p><p><strong>database/的权限属性</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">database/的权限，建议是755，属于root，root</span><br><span class="line">$ sudo chgrp root database/</span><br><span class="line">$ sudo chown root database/</span><br><span class="line">$ sudo chmod 755 database/</span><br></pre></td></tr></table></figure></p><p><strong>Linux selinux安全机制</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在/etc/selinux/config 或类似的文件里，如有SELINUX项，请修改为</span><br><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure></p><h1 id="三：结语"><a href="#三：结语" class="headerlink" title="三：结语"></a>三：结语</h1><p>网上的很多教程都过时且并不详细，提到这个又漏掉那个，本教程仍旧不敢保证你一定能成功。<br>MySQL 8.0的配置文件太多了，my.cnf conf.d/ mysql.cnf mysql.conf.d/ 等等出现了引用包含。<br><a href="https://downloads.mysql.com/docs/refman-8.0-en.a4.pdf" target="_blank" rel="noopener">官方文档</a> 六千多页，够玩儿一年。  </p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>开源精神:Linux</title>
      <link href="/title/d8add382/"/>
      <url>/title/d8add382/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2018/10/16/idZXSf.jpg" alt="Linux" title="Linux项目发起人:Linus"><br><a id="more"></a></p><h2 id="Linux的好，谁用谁知道"><a href="#Linux的好，谁用谁知道" class="headerlink" title="Linux的好，谁用谁知道!"></a>Linux的好，谁用谁知道!</h2><p>如果说，有人不知道Linux或者Linus(林纳斯)的话,我认为这只是一件普通得不能再普通的事了；但是，有人不知道安卓(android)吗？有吗？但凡是一个学生，不管小学生抑或是大学生，人人都知道安卓，即便用的是Apple家的产品，他也不可能不知道安卓。可见，安卓非常出名，实际上，今天繁荣的互联网世界背后，安卓大有功劳。可是，人们就是不知道Linux。</p><p>说起Linux，许多人都是摇头，要不是看不上它的黑框框就是嫌弃上面没有Office，反正Linux历来不受大众喜爱。可用Linux做的安卓却倍加受宠，这也说明，Linux能得到大众的喜爱，只是他们喜爱的是Linux以安卓出现的样子，包装得好看了，大家就喜欢了，一漏出原型，众人又摇头叹气。</p><p>在过去的几年里，我在Linux上花了许多时间，最初完全不懂，系统也是傻瓜式的安装，反正就安好了，就开始用。那时候完全不懂电脑，即便会用Office，会写文档，但是，现在看来那就是三脚猫功夫，充其量算是会点鼠标罢了。慢慢的，随着学习的深入，我发现，Linux真是个宝啊，软件多，安装快，够安全，够稳定，功能逆天，手机端，桌面端，服务器端，嵌入式，跨平台，甚至还能连接卫星。这些发现让我精神振奋，有如发了笔大财。今天，我已经完全适应并爱上了Linux，Windows系统也只有用部分软件时才打开，而在Linux下工作成了我的常态，研究生阶段开始，每天三小时以上用在了Linux系统上，现在这些文字也是在Linux下用Vim写的。用Vim或者Emacs真是一种享受和解放，因为输入文字不需要鼠标，一切操作都可以用简单的指令解决，写作效率提升至少百分之50以上。所以，作为信息时代的你，为什么不用Vim写作呢？</p><h2 id="Linux是什么"><a href="#Linux是什么" class="headerlink" title="Linux是什么?"></a>Linux是什么?</h2><p>这个问题每个人有每个人的看法，我的看法是:</p><blockquote><p>Linux是一个强大安全稳定的操作系统内核，是一种能解决绝大多数用户问题的真正的先进技术。</p></blockquote><p>GNU/Linux就像大家熟知的Windows一样，是一种操作系统，是一个远远优于Windows的系统，该系统诞生于上世纪90年代，并在10年前生下了安卓。说起Linux就不得不提他的创始人Linus，也就是这位大神!<br><img src="https://s1.ax1x.com/2018/10/16/idZXSf.jpg" alt="Linux" title="Linus对英伟达表达不满"></p><p>正是他对学校教学所用的Minix系统的不满,使他谋生了自己写一个操作系统的念头，并且坚持了下来。在他21岁的时候，他只是芬兰赫尔辛基大学的一名大学生，他一个人独立的写出了Linux的第一版，时间为1991.8.25.<br>起初起名为Frex,意为Free<br>Unix:免费的Unix。只是当Frex传到服务器上保存时，他的小伙伴觉得干脆把Linus的名字修改一下，用Linux做为保存Frex的文件夹(目录)名。以后，越来越多的人就用Linux来指代这个系统了,所以，Linux的名字不是Linus自己用自己的名字起的，因为，当时的他就只是为了玩一把，就是写了个怪胎，只是没想到越发展越强大，越来越多黑客加入了该系统的开发，很快这个系统就初具规模，并通过互联网传播到了世界各地。今天，该系统(实际上是一个内核)仍然由Linus领导，全球各个角落的人通过互联网协同工作，协力推进该项目的发展。像谷歌，微软，Facebook，阿里巴巴等大的互联网公司都在为该项目贡献代码，该项目也成了地球上最大跨时最久的开发项目，到现在都还在开发，代码已超过2500万行，一个人一辈子也不可能看完。</p><h2 id="1990那个年代"><a href="#1990那个年代" class="headerlink" title="1990那个年代"></a>1990那个年代</h2><p>1990年，中国还处在农业社会，那时的世界与今天的世界是十分不同的，人们无法用电话通话，沟通只能靠书信，那时候是真正的家书，贸易不发达，人口流动也不是那么频繁，改革开放也才稍显威力，然而国外的开源运动却搞得如火如荼，即将进入一个崭新的时代。1991年Linus花了三千五百美元，买了台电脑，装上了Minix，却发现上网老是出问题，干脆自己写一个处理工具，然后由这个小工具慢慢发展成了一个大的内核。那时候正是开源时代，由MIT的理查德.斯托曼创建的GNU项目也搞得风生水起，但是GNU有工具没有系统核心。而Linux刚好补上了这个空缺，两相结合，颇为完美，这样，结合GNU众多优秀的系统软件，GNU/Linux横空出世，并迅速得到了全球各地的开发人员的喜爱。开放源代码的理念一直深深的植根于理查德的脑中，他提出了GPL通用公共许可协议，完全开源了源代码，所有人都可以修改和再发布。这样的理念在有的人看来太危险了，通常的公司都会把源代码保护好，要是被谁用了还要打官司告对方，怎么会完全公布呢?可是，人家斯托曼就是玩得不一样，实际上他是被麻省理工学院那群人给气了才跑出来自己建立GNU的，他确实做到了，这很了不起。<br>95年，中国开始有了互联网，但是用Linux的肯定不多，那时长城也还没有，一切都是同世界互联，也就20多年，谁能想到今天的互联网会如此庞大繁荣，如此活力焕发呢?</p><h2 id="开源精神"><a href="#开源精神" class="headerlink" title="开源精神"></a>开源精神</h2><h3 id="技术模型铁道俱乐部的黑客们"><a href="#技术模型铁道俱乐部的黑客们" class="headerlink" title="技术模型铁道俱乐部的黑客们"></a>技术模型铁道俱乐部的黑客们</h3><p>在上世纪,大约1958年，在MIT(麻省理工学院)，有着IBM产的超大的计算机，占据一整个房间。一些不安分的学生总是想摸摸这台大机器,运行他们的程序。可是，即便是得到特权的学生也只能由操作员为其运行程序。这群学生都是来自一个喜欢铁路模型的俱乐部–技术模型铁道俱乐部。该俱乐部发明的术语是:设备中零件不工作了叫”losing”,当零件坏了那就说它”munged”,天天上课的人就是个”tool”,如果一个项目只是参与其中就会带来莫大的乐趣，那么就叫”hack”<br>那时MIT的约翰.麦肯锡在电气工程学院教授一门在今天称为”人工智能“的课，尽管当时大部分人都不看好这门技术，但是铁道俱乐部的这些捣蛋鬼都选了该门课程，并在AI实验室扎根了下来。</p><p>“hack”最初大体就是由这群MIT的学生发明的，干事效率高的人自称为”hacker”(今天翻译为黑客).这群黑客的伦理是:</p><blockquote><p>对计算机的访问应该是不受限制的，完全的，任何人都有动手尝试的权利。</p></blockquote><p>他们相信把东西拆开而理解其内部原理并改进是重要的，任何试图阻止他们这样干的行为都是不被允许的</p><blockquote><p>信息应该可以自由获取<br>不能迷信权威<br>计算机让世界更美好</p></blockquote><p>这些是黑客们不断完善的信条，经过众多黑客的共献，AI实验室成了黑客伦理的化身。</p><h3 id="最后一名黑客"><a href="#最后一名黑客" class="headerlink" title="最后一名黑客"></a>最后一名黑客</h3><p>大约在1971年，一位喜欢计算机技术的天才从哈佛退学并加入了MIT,并同样加入了AI实验室，他就是斯托曼。在AI实验室，他们一起搞技术，写程序，分享黑客精神。直到一天，实验室的黑客们为了生计而被公司挖走,他们都走了，剩下斯托曼一个人，他很伤心，因为他为之奋斗的实验室已经分崩离析了，人走了，就什么也没有了。</p><p>为了推广黑客伦理，斯托曼离开了MIT,并于1983年,创立了GNU(GNU is Not<br>Unix)。他把自己的理念都融入到了GNU里面，设置了十分霸道的GPL通用公共许可协议:</p><blockquote><p>凡是用到了GPL协议里的代码，那么你的整个产品都必须开源。</p></blockquote><p>他想通过GNU计划继续推广他的黑客伦理，让更多的人使用计算机,无障碍地查看和修改代码,完善产品。<br>斯托曼几乎就是地球上最后的黑客了，现在看到的黑客都是第四代，第五六七代黑客了。实际上，今天的黑客更多的是骇客，他们喜欢搞破坏而不是分享理念，推动开源的发展。</p><h3 id="GNU-Linux"><a href="#GNU-Linux" class="headerlink" title="GNU/Linux"></a>GNU/Linux</h3><p>时间来到90年代，当Linus把Linux推向互联网时，GNU计划发现这正是他们需要的，于是，GNU/Linux横空出世，结合双方的优点，Linux发展得十分顺利。人们对开源持积极态度，即便有众多公司把代码看成机密，但是人们对获取源代码并修改的意愿一直存在。而Linux是完全开源的，任何人都可以下载并查看，修改<a href="https://www.kernel.org/" target="_blank" rel="noopener">源代码</a>。<br><img src="https://s1.ax1x.com/2018/10/18/iw0m5R.jpg" alt="Tux" title="Linux吉祥物:Tux"></p><h3 id="今天的开源世界"><a href="#今天的开源世界" class="headerlink" title="今天的开源世界"></a>今天的开源世界</h3><p>今年，微软收购了Github这个全球最大的开源集散地，最大的男性交友网站,并且承诺继续维持原有的运作模式，越来越多的公司也都开始采用开源产品，因为</p><blockquote><p>免费<br>有人打补丁<br>开源产品可迅速上线使用</p></blockquote><p>似乎，今天又回到了开源运动火热的年代，不知道斯托曼现在怎么看这个世界。但是不管怎么说，要感谢这些黑客和天才，没有他们，就没有安卓，没有今天繁荣的互联网世界!<br><img src="https://s1.ax1x.com/2018/10/18/iwwbgf.jpg" alt="stallman" title="自由软件之父:理查德.斯托曼"></p>]]></content>
      
      
      <categories>
          
          <category> 互联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> IT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>十年</title>
      <link href="/title/bdfafec0/"/>
      <url>/title/bdfafec0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2018/10/13/iNhyfH.jpg" alt="我们的十年" title="我们的十年"></p><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="230" height="86" src="//music.163.com/outchain/player?type=2&id=2116549&auto=1&height=66"></iframe><p>此文成于2018.5.12汶川大地震十周年忌，今日将其发表。文中回顾了十年来我视角下的世界变迁，限于记忆和篇幅，文中每一句话均对应一个历史事件和重大的社会发展阶段！愿诸君共缅怀这段时光，这十年是我们90后真正成长并接过社会发展重担的十年，是我们成家立业，求学经商变迁的十年，也是我们90后追求自由，幸福，公平生活的十年，回顾于此，心中颇多感触，噫吁嚱！（谢波,于成都理工)</p><blockquote><p>   十年前稚气未脱是小孩，十年后老司机终日开小差。</p></blockquote><blockquote><p>   十年来，腹胸腰背有所长，<a href="https://baike.baidu.com/item/父亲/1465141" target="_blank" rel="noopener">父母</a>两鬓却微白，额间细纹埋！</p></blockquote><blockquote><p>   十年前，绿皮火车慢徘徊，今朝高铁祖国遍地开。</p></blockquote><blockquote><p>   北上广深，四大神针，撑起异度文明。</p></blockquote><blockquote><p>   十年前安识灰霭？<a href="http://blog.sina.com.cn/s/blog_5b2684c70102vgqg.html" target="_blank" rel="noopener">美帝普及</a>全民怼雾霾。PM2.5,你好坏！</p></blockquote><blockquote><p>   嫦娥先去，玉兔又来，蛟龙今又下海，中华科技，日新月异，遍地人才栽。</p></blockquote><blockquote><p>   智能时代找AI，<a href="https://baike.baidu.com/item/%E6%96%B0%E5%9B%9B%E5%A4%A7%E5%8F%91%E6%98%8E/1549722" target="_blank" rel="noopener">四大新贵</a>，人人爱，人人为你站台！</p></blockquote><blockquote><p>   零八奥运今犹记，如今君又来，<a href="https://baike.baidu.com/item/2022年北京冬季奥运会/12061628" target="_blank" rel="noopener">北张二市</a>等着你，华夏必将更精彩。</p></blockquote><blockquote><p>   全球变暖，气温不要升太快？烤化两极冰盖，直把东京热坏！</p></blockquote><blockquote><p>   十年前慧聪网自诩掌平台，十年来，马云怪才，缓缓来，阿里宝贝升级打怪，一幕幕，一招招，呈现女性最爱！</p></blockquote><blockquote><p>   来的终究会来，任你癫狂，我无惧任何祸灾。</p></blockquote><blockquote><p>   十年前它颐指气使，暗控国之命脉，如今杀出个大boss太厉害！</p></blockquote><blockquote><p>   什么是谈笑风生潇洒自在，什么又是香港记者跑得快？全都是苟屁，给我滚开！</p></blockquote><blockquote><p>   有人偏爱“闷声大发财”，有人好色又贪财，为祸妇女，<a href="http://www.360doc.com/content/11/0929/08/7381203_152057015.shtml" target="_blank" rel="noopener">奇怪日记</a>怀中揣！</p></blockquote><blockquote><p>   反腐大戏扣人心怀，贪腐代表犹记陕西<a href="http://media.sohu.com/20130121/n364175335.shtml" target="_blank" rel="noopener">表哥杨达才</a>，车祸现场，竟能喜笑颜开？</p></blockquote><blockquote><p>   见你搂财，也见你人走茶凉倒台，监狱中索未来，回味往昔，终识儿时田园时光最自在，邻家姑娘最可爱！</p></blockquote><blockquote><p>   金融危机，华尔街哭泣，我有<a href="https://baike.baidu.com/item/%E5%9B%9B%E4%B8%87%E4%BA%BF%E8%AE%A1%E5%88%92/8497463" target="_blank" rel="noopener">4万亿</a>，高楼遍地林立，房奴满街无头绪，可气，可气！</p></blockquote><blockquote><p>   十年前汶川挂人心怀，逝者不在，十年来，蜀地重开，重建家园最实在，我们仍要打牌，犹爱吃菜，家有好女养，贤胥万里来！</p></blockquote><blockquote><p>   十年前<a href="https://baijiahao.baidu.com/s?id=1583491930247443643" target="_blank" rel="noopener">安卓出生</a>是小孩，十年来，iphone来到X时代，果粉卓粉，相杀相爱,手机反复买，旧的不去新的不来。</p></blockquote><blockquote><p>   网络成了新平台，主播变大拿，网民成拥虿！键盘侠治国滔滔不绝，一句不对，怼你祖宗十八代！</p></blockquote><blockquote><p>   猫狗是萌宠，Panda最可爱，Bilibili的小哥哥小姐姐安在？日漫<a href="https://baike.baidu.com/item/一人之下/19691179" target="_blank" rel="noopener">国漫</a>，腾讯动漫，马化腾手握两撒手锏!</p></blockquote><blockquote><p>   Dota传奇，英雄联盟奇迹，今晚吃鸡，大吉大利！</p></blockquote><blockquote><p>   直男癌，绿茶婊，帽子扣得真不少，千好万好，愿意傻傻关心你的人才最好！</p></blockquote><blockquote><p>   <a href="https://baike.baidu.com/item/海天盛宴/6932418" target="_blank" rel="noopener">海天盛宴</a>，人体器官，二代们使劲撒欢，王思聪炮轰众客官：不要脸！</p></blockquote><blockquote><p>   十年前下馆子，今有外卖，外卖外卖，信誉犹在？</p></blockquote><blockquote><p>   十年前人等车，十年后车等人，人车车人分不清，滴滴伴你<a href="https://new.qq.com/omn/20180826/20180826G0H18K.html" target="_blank" rel="noopener">安全出行</a>？</p></blockquote><blockquote><p>   十年前，购物逛街，十年后购物上网，双11成购物节，单身狗遭了一劫又一劫。</p></blockquote><blockquote><p>   过年回家，七大姑八大姨笑哈哈，男友哇，女友哇，赶快给我<a href="https://baike.baidu.com/item/每逢佳节被逼婚/5708171" target="_blank" rel="noopener">带回家</a>！</p></blockquote><blockquote><p>   全民健身跑起来，约你，来不来？</p></blockquote><blockquote><p>   通信便利，交心不在，相顾无言，低头微信畅开怀—还真是怪！</p></blockquote><blockquote><p>   空间朋友圈，秀完美食秀恩爱，可劲儿使能耐，秀得恩爱，死得最快！众人还把你埋汰！</p></blockquote><blockquote><p>   计划生育，国之大计，终遭抛弃，解放妇女生育权利。</p></blockquote><blockquote><p>   可男多女少，女友不好找，Gay佬闺蜜气氛诡异，似塑料姐妹花小猪佩奇。</p></blockquote><blockquote><p>   十年变化可真是快！！！来到了什么新时代。</p></blockquote><blockquote><p>   这是一个什么样的时代？这是学‘习’的时代，知识千金难买，自由成为真爱！</p></blockquote><blockquote><p>   90来00来，一代又一代，绽放青春的精彩，定义国家的未来，说什么90后无用，可识天生我才？</p></blockquote><blockquote><p>   这是一个新时代，梦想仍在，小伙子不要怕，摔倒后侬可爬起来！</p></blockquote><blockquote><p>   愿君观后莞尔笑颜开，奋力拼搏方可逐梦未来！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 回忆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 十年，变迁 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浅谈现代操作系统历史</title>
      <link href="/title/500c6ff0/"/>
      <url>/title/500c6ff0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/10/30/K5t06P.md.jpg" alt="OS">　<br><a id="more"></a></p><h2 id="智能手机操作系统"><a href="#智能手机操作系统" class="headerlink" title="智能手机操作系统"></a>智能手机操作系统</h2><p>智能手机的使用已十分普遍了。不论苹果或是安卓系统的智能手机都拥有巨大的市场，拥虿甚广！可是，有谁能想到这个如此受欢迎的东西也就诞生十来年。2007年11月份，安卓从加州山景城谷歌公司溜出，并迅速引领了移动互联网的发展！</p><p>大概在2000年代，手机市场还是由诺基亚统治，一个做木材生意的公司，把手机做到全球第一确实了不起。与此同时，一名叫做<a href="https://baike.baidu.com/item/AndyRubin/7170474" target="_blank" rel="noopener">Andy Rubin</a>的小伙子创立公司并开发了一种新的相机系统，用于图片处理。但是相机市场的下滑，迫使该公司转向于手机系统。他利用开源的<a href="https://baike.baidu.com/item/linux/27050" target="_blank" rel="noopener">Linux</a>稳定内核作为其手机系统的核心，成功开发出了一种能上网的系统，后来这个系统在2005年被谷歌收购，经过进一步开发，于2007年11月释出，这就是安卓。于此同时，苹果公司也发布了一款手机系统，它的内核来源于BSD版本的Unix，同Linux属于同族不同分支的系统。我们可以这样认为，即苹果系统是安卓系统的叔叔。他们的共同祖先是贝尔实验室的Unix系统。当然，这个贝尔实验室还出过七个诺贝尔奖，互联网和C语言，C++语言也诞生于此。</p><h2 id="PC操作系统"><a href="#PC操作系统" class="headerlink" title="PC操作系统"></a>PC操作系统</h2><p>除了手机操作系统，我们常见的还有电脑上的操作系统，这种系统发迹于上世纪的美国，最开始分为多个派别，后来大体两派：一派是比尔盖茨的微软，一派就是各大公司和大学，实验室合作的或独立开发的系统，其中贝尔实验室的Unix操作系统是最成功的。今天大家看到的Windows10操作系统则源于1981年比尔盖茨花5万美元从Seattle Computer Systems（西雅图计算机系统公司)买的DOS系统(磁盘操作系统，就是一个黑框框)。聪明的比尔盖茨结合IBM的PC电脑，售卖该DOS系统，赚取大量利润，并以此为基础改进DOS系统，并最终演变出了Windows NT系统，也就是Windows95，Windows98，Windows2000。而后Windows NT不断进化，诞生了Windows XP，Windows Vista, Windows 7, Windows 8/8.1，Windows10。Windows系统是一个很好用，但却是一个很复杂而很难学习的系统，其内部为了兼容以往的软件和系统，保留了大量不合宜的代码，这也就导致Windows是地球上架构最烂的系统，最容易受到黑客攻击的系统。客观讲，Windows是个很成功的产品，但却不是像苹果那样的杰作。Windows的发迹，主要是因为比尔盖茨商业头脑太厉害，少有干得过他的。</p><p><img src="https://s1.ax1x.com/2018/10/13/iNWX2n.jpg" alt="windows" title="来源:百度图片,Widows"></p><p>另外一个电脑操作系统是苹果的Mac os x操作系统，源于乔布斯被苹果公司开除后自创的达尔文系统，底层依旧是Unix核心。当乔布斯重回苹果时，带回了该系统，并开发出了苹果系统。苹果系统定义了现代操作系统的图形用户界面，下拉菜单，按钮，鼠标等控件。微软的电脑界面，菜单等等都是学的苹果的，要不是苹果，微软可能还是有一个黑框框。</p><p><img src="https://s1.ax1x.com/2018/10/13/iNhU61.jpg" alt="Mac os" title="来源:百度图片,Mac OS"></p><p>第三类电脑操作系统是Unix操作系统的变种Linux衍生版，因为Linux只是一个内核，通过结合不同的系统软件就是不同的款，但是核心一致。所以这一类操作系统特别多，因为开源，任何人可以拿过来改一下并发布。我现在写这篇文章的操作系统是基于Linux内核的Ubuntu(我现在已几乎不用Windows了)。目前Ubuntu是最成功的桌面版Linux操作系统，其他的Linux操作系统还有Debian，Centos，Redhat约上百款。安卓也是基于Linux的，可见Linux非常强大，手机端和电脑端都吃得开。</p><p><img src="https://s1.ax1x.com/2018/10/13/iNhwm6.png" alt="Ubuntu" title="来源：我的桌面,Ubuntu"></p><h2 id="服务器操作系统，超级计算机操作系统"><a href="#服务器操作系统，超级计算机操作系统" class="headerlink" title="服务器操作系统，超级计算机操作系统"></a>服务器操作系统，超级计算机操作系统</h2><p>由于这一类是属于行业的操作系统，民间几乎不可能看到，但是它却在背后默默的为亿万人民服务。<br>比如你购物需要进行交易结算，用任何的App都需要后台支持，这些都要靠服务器操作系统来处理。目前服务器操作系统分为两大阵营，一派微软，一派Linux。微软在开发PC版本的操作系统的同时也开发了服务器操作系统，目前60%左右的服务器操作系统是Linux，因为它架构好，易修改，稳定。服务器必需要稳定，试想你在付款，一下卡了，你的钱不就白花了吗？这也是Linux的强项，Linux的一款叫做Centos的系统据说创下过５年不关机不出事故的记录，对比微软动不动就出事故，犯卡，Linux能统治服务器自然就合情合理了。</p><p>另外一个很重要的操作系统是超级计算机的系统，因为超级计算机管理的存储和运算节点十分的庞大，所以系统必需稳定好用。而Linux刚好满足这些特点，Linux再次占领该领域，目前，世界前500强超级计算机全都使用Linux系统，中国的天河，神威太湖之光也是中国基于Linux内核自主研发的。</p><h2 id="物联网系统"><a href="#物联网系统" class="headerlink" title="物联网系统"></a>物联网系统</h2><p>随着社会生产力的发展，传统互联网的使用有了更高的追求方向，专家们提出了基于万物互联的物联网概念。物联网就是把所有能连网的电器都用网连起来，比如空调，冰箱，汽车，卫星，手机，智能手表，智能自行车，智能椅子，甚至是床都可以用网连起来。人们会问，床不是没网吗？现在没有，可只要未来有需要，嵌入式工程师们早晚会开发出来的，只需对相应硬件给予软件，配上网络。目前，专家们提出的物联网，在我看来是通过中央控制器控制各种不同的物理器件，获取大数据存储在云服务器上，结合新的技术，例如人工智能，开展新的服务模式，为消费者提供更好的产品和服务。针对不同的器件，功能不同，就需要设计不同的操作系统，显然空调和床的功能不一样，这不像手机，品牌不同，但功能差不多。目前，众多物联网公司正利用Linux内核开发物联网操作系统，也就是嵌入式系统，其实安卓系统也是一款嵌入式操作系统。我认为，今后几十年，我们的家庭和城市治理要更多的依靠物联网基础设施，人们的生活便利程度不断提高，未来的社会将是一个相当程度靠网络管理的高度智能化的社会。当然，政府肯定还存在，但是重要性会下降，它不会像今天那么重要。可能在我们这代人四五十岁的时候，我们的家主要是有智能器件打理，家政服务就不再需要了。各种专门仪器会处理扫地，洗衣，烧水，洗碗，铺床等等工作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>按目前的分类法，操作系统分为手机端，服务器端，桌面端，物联网端。其中Windows在桌面和服务器端能做；苹果在手机和桌面端能用；Linux在手机，桌面，服务器，物联网上都能做！看来Linux是个非常有用的技术，这也是我下心学习它的原因，因为我赌定它会成为未来几十年社会发展的动力。未来，随着新技术的出现，应该还会有新的系统出现，可能就衍生自Linux。未来的世界将是万物互联的世界，我家的冰箱可能和你家的冰箱在聊天，在恋爱，谁说机器就不能恋爱呢？洗碗机可能和灶台吐槽主人的烹饪技术，阳台看花的仪器可以向你报告今天该花吸收的二氧化碳量，桌子和椅子组成一家人为你服务。这样想想，感觉未来真是挺美好的，我们的生活将和智能的器件关联起来，人类的历史也会是人和物的历史。人类只能走这条智能化，信息化的路，所以，让我们为这一天的早日到来努力奋斗吧。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我对英语学习的看法(一)</title>
      <link href="/title/3dfb8a8e/"/>
      <url>/title/3dfb8a8e/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/08/19/mlsRJO.jpg" alt="韩雷和李梅梅"><br><a id="more"></a></p><h1 id="英语学习"><a href="#英语学习" class="headerlink" title="英语学习"></a>英语学习</h1><h3 id="英语学习的目的"><a href="#英语学习的目的" class="headerlink" title="英语学习的目的"></a>英语学习的目的</h3><blockquote><p>A.为了工作<br>B.为了出国<br>C.为了旅游<br>D.为了学术<br>E.为了考试</p></blockquote><p>想来,英语的学习目的大体如此,并不绝对,各种想法都有.我呢,少时不知英语的重要性<br>完全对英语漠视甚至讨厌,有段时间进而讨厌起英语老师来了,现在来想来,实在是傻.<br>后悔是没后悔药了,好在我把自己给救过来了,英语的学习也给我快乐和目标.<br>以前我学习英语,从来都是为了考试,从不想为什么,因为心里讨厌着呢.后来,上了大学,<br>我发现不用英语不行了,交流,工作,学习迫使自己用英语,这个是很大的转变,因为一旦你开始<br>用它,你就会发现语言也不是那么讨厌,相反,是十分有用,好用,可用.<br>我自己对英语有如此大的态度转变可能是因为:</p><blockquote><p>1.英语,我学来不是奔着考试去的.<br>2.用什么学什么,太高大上的语法对我并无作用,当然语法十分重要.<br>3.找对好的方法,学习英语也不是那么难吧?</p></blockquote><p>最大的转变还是大二去酒店做兼职的时候，一个外国客人吃披萨还是什么时，问我要胡椒(pepper),<br>我给听成了纸(paper),，所以我就给他递上了纸巾。接下来，有趣的来了，他感到不可思议，睁大了眼睛，<br>疑惑为什么我会给他纸巾，后来经理来轻松的化解了这个小问题。但是，事后我反思，他为何会很吃惊？<br>看到这里，不知道，中国同学能发现问题吗？如果，老外真的说的paper你们会给他什么呢？<br>是一张写字的纸还是餐巾纸呢？这里就要谈到语言的不同了，这属于语用学的内容。在中文里，纸代表写字的纸，<br>也代表餐巾纸，卫生纸等等纸，这是中文的博大精深之处。但是，英文不是这样的。英文里的纸就是paper,<br>指代写字的纸张，餐巾纸该叫napkin或者tissue. 老外脑袋里无法把这两个概念，纸，餐巾纸等同起来，<br>因为他们完全不一样嘛！所以，你可以想象”一个外国人说：小伙子，给我拿胡椒过来，然后我屁颠屁颠的给了他餐巾纸，<br>他当然觉得不可思议了“，怕是觉得我是弱智了，但是语言的差别，他也不知道，他不知道中国人会把他们用来写字的纸和<br>餐巾联系起来。但是，这个发现，给我带来的思考却十分的丰富，原来，我学的英语只是我脑袋里塑造的一个假象，全是乱<br>的。后来，凡是听到paper或pepper之类的，一概递上胡椒，效果很好，他们还夸我机灵，有时还有小费。这也是改变我，<br>并使我重新自学英文的一大出发点吧。<br>以上的总结,可能还不周延.但是,已明显看出我自己摆脱了对英语的厌恶,而且超过了<br>对考试的要求；心态上,不再把考试当成学习它的目标了,所以,有个好目标很重要.<br>但是,中国的教育就是要逼你去死扣语法,做一些怪题,学一口哑巴英语,说来也怪,大家相安无事,<br>就这么学了十几年的英语,也是过来了.</p><h3 id="英语学习的方法"><a href="#英语学习的方法" class="headerlink" title="英语学习的方法"></a>英语学习的方法</h3><p>各种方法都试过,但也仅限于试过,没坚持下来,多好的方法也没有用.据我的观察,任何一门语言<br>学习,都需要建立良好的基础知识,这些知识是学好语言的关键,很不幸,中国人被传统教育坑害惨了.<br>很多英语老师拿着学究派的语法死讲,语法确实重要,但是连词都吃不透,句都不懂,如何谈语法?<br>我想,语言学习可以由以下一些点出发:</p><p><strong> A.学习基本词汇,词汇分层:基本词,延伸词,高层词,词网 </strong></p><p>  一门语言的诞生过程中,单词才会渐渐多起来,很多词在历史中,一直在用,但是基本词义是一直存在的,进而延伸出词,最后归纳出高层词汇.举例:circle 这算是一个高层词汇,它往下可以得到各种和圆性质有关的词汇:circular,circuit,,circumstance,bicycle,cycle等等.这些词汇,都是从circle这一物理样态里衍生出来的.同样的比如:apple,bad,gold,tin四个词,是英语中最古老的四个词汇,今天亿万人仍旧在用,词义也没变多少,所以基本词汇很重要.<br>  高中就被老师忽悠买了牛津高阶词典,但是几乎没用过的同学一定很多,我也是最近才开始想到,<br>  牛津3000词汇不就是那些重要的基本词汇的总结吗?牛津词典不就是用这几千词汇来解释多达几十万的词汇吗?<br>  以前,中国人讲究大词,比如讲一个人奇怪,有的人就能用grotesque这种词汇,但是这是一种花式用法.<br>  什么意思?就是:这种词,多见诸于媒体报刊,博眼球的,写作要是用这个,也太怪了,不得体.<br>  然而中国人甚觉良好,我以前也是,每回用了高大上的词汇还不忘夸自己几句,同孔乙己教小孩回字的<br>  四种写法一般,沾沾自喜.</p><p><strong> B.学习简单的句式结构 </strong></p><p>  有了单词,要学会一些基本的句式结构,然后将词用起来,这点很重要.传统的语法书对于各种句式,结构,<br>  语法,总是不厌其烦的讲述.我认为,这些书,又有很多是大家(大方之家)写的,一定很好,所以我以前还拿<br>  张道真的语法来看,但是一看就发现看不下去.一种句型,有什么规则,然后列出几条例外规则,整本语法书<br>  就是在书写规则,例外规则,几张不规则动词变化表,什么特殊句式表,我背不下,记不了.学习英语的信心陡然下降,还感叹:英语可真难啊!实际上,英语中没有那么多例外,也没那么多套路,基本句型五种,时态分两种,语态两类,语气四种.大体如此.今后,我想我应该会慢慢更新从旋元佑老师哪里学习来的语法概念吧!</p><p><strong>C.广读英语</strong></p><p>  读英语,不是去看什么美剧,什么?不是很多人都说看美剧能学英语吗?呵呵,看电视剧学英语只能学得只言片语,那些说看美剧学英语是指学地道的口语,他们本身水平较高了,所以他们说这个好.但是一个外国人一来就学’仙人板板‘,这种四川话中的地道的土话,你觉得学得会吗?或者说有意义吗?所以初学者,肯定不是要去学英语中的这类词汇,而美剧中充斥着类似的各种典故,政治隐射,俚语,不是有点儿水平的人,看不懂.中国人一提老王,马上就想到戴绿帽的感觉.但是,外国人却不觉得,对于中国人来说,外国人讲他们的老王的时候,我们也不会觉得好笑的,这也是很多中国人并不觉得有些<br>  美式笑话好笑的原因.但是,美剧可不可以看呢?当然可以啊,但是看就老老实实地看,不用抱着学英语的<br>  态度去看,那样很累,就是放松的开心就好了,可能会学到一些口语表达.比如,我以前看生活大爆炸的时<br>  候,也是轻松自在,也学了写口语,谢耳朵的搞怪确实连我这个理科生也觉得好笑.<br>  论述这么多,回过头来,英语还是要多读文章,标准的英语,就是一根准绳,培养最好的语言基础,<br>  一旦读得多了外国的老王你也认识了,那就差不多了,你的语感自然在阅读的过程中慢慢就来了,有些表达<br>  顿时就蹦出来了,这是我的经验了.但是,读什么呢?读新课标?其实都可以,关键是要符合语法标准且同<br>  自己的水准契合的文字材料,最好不要有中文,多读,不认识的单词多看几遍,慢慢就知道意思了.<br>  我最开始对英语一窍不通,现在好一点儿.有一天,发现了BBC的软件,下了一个,慢慢看新闻,那种英语<br>  是最传统的英语了,新闻既有意思,又提升自己的见识和眼界,随后我连我自己的手机也设置成<br>  英文版本的(这不算崇洋媚外吧),大部分软件都是英语的,开始不认识,但是久了就知道各种按键对应的<br>  英语单词了.后来,我的手机就一直是英文版本的了,现在想想都好几年了,因为天天用,这种英语习惯<br>  已经进了脑子了,又促进了对英语的兴趣.然后看的文章也偏向英语,可以说,阅读改变了我,我是从最底层<br>  走出来的,能在精神上把自己活得像个国际人士(自诩的)算是不容易了,但是我还要继续努力,还有很多经典<br>  的英语书籍等待着我.</p><p><strong>D.勤练听力</strong></p><p>  听力,怎么说呢,也是随着用BBC,就在BBC上下它的播客节目来听,十分有意思.慢慢的,听的材料就熟悉了,<br>  语感就来了,而且回去发现四级自己可以听写出每个单词,我都没想到.我平时,在图书馆听,路上偶尔听<br>  反正节目有意思,有深度,不觉得是练习听力,其实这就是我的生活,和别人听音乐是一样的,成了一种爱好<br>  了.所以,我建议愿意练习听力的同学,直接上外国网站去下载播客节目来听.这些年听过的播客节目有:BBC的CrowdScience,BBC Culture,BBC News,Trending还有美国航空航天管理局NASA的播客,以及全球的两大顶级科学杂志Science和Natured的播客,当然,这个比较难,全是地球上的前沿的科技和技术,我发现在<br>  很久一段时间内,我都是靠这些播客来了解科学发展,人类的进步,中国大陆几乎不讲这些,或者报道落后.<br>  从NASA开播客来看,美帝对科学的普及都到了一种平常的状态,而中国民众却很少有机会得到科学普及,<br>  不要讲那种顶级杂志了,就是小的媒体,除了CCTV10那走进科学,天天找鬼,震惊,还能有什么呢?<br>  这种种,打开了我的见识,提升了英语听力,对语言的学习又达到了一种新感觉.所以,听力不要用四六级,<br>  这是我的看法,可能不适用,但是,我就是这么过来的,我相信其他人只要愿意,也能做到.听得多了,语感<br>  自然有的,年轻人,还是要多提高一下自己的知识水平.举个例:有一次在听Nature两主持人讨论考古学家<br>  发掘工作时,主持人来了句:Which bEgs a question. 我马上就把它理解成了:’那么问题就来了’这句话,<br>  当时在中国大陆这话很火,是网友们恶搞蓝翔挖掘机的,但是,英语里这样的表达,我就觉得理解起来就很好,<br>  简直是活灵活现啊.语言,终归要用来听和说的,要多练习,希望有一天,能成为自己生活的一部分,<br>  就像我们伟大的汉字一样.</p><p>  下面就结合看旋元佑老师的书籍得到的知识将一些语法知识,记录在此,希望自己十年后能回来看看,<br>  这是写给未来的信吧,也可以当成写给儿子女儿的英语入门读物,当然,也一并写给未来妻子了,<br>  亲爱的,期待你的到来.也欢迎有兴趣的人来看看,讲得不好,你可以指出.(Aug 13 2018)</p><h3 id="英语的词汇类型"><a href="#英语的词汇类型" class="headerlink" title="英语的词汇类型"></a>英语的词汇类型</h3><p>英语中一共有十类词,大体分为下面十类,根据用法,有些句子和词可以变化成相应的词.</p><p><strong>十大类词</strong> 冠词 名词 动词 形容词 副词 介词 代词 连词 助动词 叹词</p><p><strong>名词类</strong> 名词 动名词 代名词 名词从句 不定词</p><p><strong>动词类</strong> 动词 分词 不定式 动名词 介词</p><p><strong>副词类</strong> 副词 状语从句</p><p><strong>形容词类</strong> 形容词 分词 关系从句</p><p>上面的分类是我在阅读一些句子后结合语法给出的分类,我发现这些词类广泛的用于任何领域的英语中.</p><p>冠词:主要是为了指示一个名词,或事情,指示的清楚的就用定冠词,指示不清的就用不定冠词.<br>比如一个苹果,an apple就讲的不清楚,因为,这个苹果不知道是谁的,可能是你的,也可能是别人的<br>,但是确实是一个,所以用an.但是,这个苹果,the apple就指示清楚了,因为它明显指代刚刚我说的那个,<br>指示明确.所以,传统语法就讲,前文提到过的用the,根本原因就是提到过,具有明显的时空对应感觉在里面,<br>指哪个大家很清楚.所以,不需要去背传统的语法,你发现指示得清楚就用the,that之类的就好了.</p><p><strong>名词</strong>: 指代事物,事情.最普遍的一种词了,中文中也一样,因为我们人类需要对客观世界进行描述,所以一定<br>要有个名字,名词就是它们的名称啦!</p><p><strong>动词</strong>: 这个就是指动作的词汇,因为有一类东西我们无法用名词来描述,比如杀,吃,打,跑.这些词都是动词<br>当然他们有时候会蜕变成名词.可见语言里倾向于静态的描述词汇.动词和名词反映的是人们的时空观,尤其是<br>词汇诞生时,创造者一定有时空的观念在里面.这点后文还会专门细讲.</p><p><strong>形容词</strong>: 要看蚊子长得帅不帅,大象跑得快不快,具体问题具体分析.这是我高中物理老师的原话,我们对一些<br>事物需要一种主观性或客观性的修饰词来描述,这就是形容词的基本作用.漂亮,帅,高,快,有趣的都是修饰<br>性的,都可以作为形容词.</p><p><strong>副词</strong>: 可是美也得有个程度,帅也有相对吧,跑得快也是相对的,所以副词就出来了,它修饰动词和形容词,表示<br>到底有多美的程度,范围,跑的具体状态.</p><p><strong>介词</strong>: 这词用法是表达所有关系,three cars of mine.同时介词也表示时空关系和动作.如:drop off 指掉落<br>脱离了原来的状态.</p><p><strong>代词</strong>: 代词可以看出指代一讲事物,但是用法有不同的地方.</p><p><strong>连词</strong>: 主要是用于构句,用连词来把两个或多个句子连接起来.为什么呢？因为,有的句子间有因果关系,时空<br>关系,并列关系等.如because,since,after,before.这样两个句子才能连在一起.I love you, because you<br>are so beautiful. I was so tired after doing such a work.</p><p><strong>助动词</strong>: 助词,就是去帮助别人啦,帮助谁呢？帮助动词啦.用来构成时态或者一种语气,也就是时间先后关系<br>和语气的用法.既然一个动词需要助动词,那么这个动词就有点虚,需要别人来帮助才能使自己把事情讲清楚.<br>Eg:If I had know, I would have done that earlier! 这里面的助动词就要帮助动词把事情说清楚.</p><p><strong>叹词</strong>: 这个没什么可以说的,惊叹,感叹,赞叹等.Suprise, Woh, Ha, Oh!</p><h3 id="英语的句子类别"><a href="#英语的句子类别" class="headerlink" title="英语的句子类别"></a>英语的句子类别</h3><p>英语的句式分为三大类,分别是</p><blockquote><p>A.初级 限定句单句:<br>B.中级 复合句:<br>C.高级 简化句:</p></blockquote><p>什么是限定句单句呢? 就是只有一个叙事的动词的句子.I love you. He has a good wife.<br>这类句子很简单,是最基础的句子,也就是我们讲得小学生都懂的那种.<br>但是复合句呢,就要稍微复杂一些,但包含的意义更丰富.复合句靠连词连接,表达一个完整的具有意义的<br>句子.When we sit here,we can see the snow-covered mountain.用when 来连接两个句子,<br>交代了我们看到白雪皑皑的山时的状态:坐着.所以这是一个状语从句.到了高级句时,就是把复合句中的废话<br>删除,只留一个动词,其他的动词都变成非谓语动词.就是动名词,分词,不定词等等.比如上面那句,前后<br>出现了we,删掉一个,然后把其中一个动词变成非谓语动词When sitting here,we can see the<br>snow-covered mountain,然后when也可以删掉了,因为sitting就是一个现在分词,具有进行的意味,表示我们<br>坐着的状态.所以Sitting here,we can see the snow-covered mountain就是最简化也是修辞最完成的句子了.<br>以上三句,就把英语的种种变化都表现出来了,以后就是逐个语法概念的的学习,直到我们看到像这样的句子:<br>The doctor of the National Meteorological Observartory Jiang Wen who is graduated from the CMU said<br>that the typooh was coming soon.<br>能简化成:The typooh was coming soon,said Jiang Wen,the doctor of the National Meterological<br>Observartory,graduated from the CMU 这样就非常不错了.(Aug 13 2018)</p><h1 id="第零章-句子的句型"><a href="#第零章-句子的句型" class="headerlink" title="第零章 句子的句型"></a>第零章 句子的句型</h1><p>英语句子就只有五种句型,其他的句型皆是由这五种句型组合得到,所以,学会分析五种基本句型是重中之重<br>常见的句子成分有主语(S),动词(V),宾语(O),补语(C)也即这四个词的(Subject,Verb,Object,Compliment)<br>的首字母,这种记法没有什么大道理,只是一种方便表达的技术性手段而已、五种句型分别为</p><blockquote><ol><li>S + V</li><li>S + V + O</li><li>S + V + C</li><li>S + V + O + C</li><li>S + V + O + O</li></ol></blockquote><p>可以看到,任何一种句子里面都有动词,相反的,什么补语或者宾语有时候并不出现,所以动词是英语句子中的<br>关键。同时,主语也是都存在的,所以,写英语作文的时候,好好想想自己主语动词交代清楚没？很多作文有主语<br>和动词,但是指代错误,称为牛头不对马嘴,让人看了产生逻辑错乱,云里雾里的,这错误我以前不懂语法的时<br>候可是常常犯的.</p><p>对于上面五个句子,我想可以用一句话来概括:某物做了什么,或者某物怎么怎么样。主语交代事情的执行者,就是<br>那个物(注意,为了描述的抽象简洁,人也看成物,这样可以用一种比较有把握的描述手段展开讨论).动词承载动<br>作,宾语成了动作的对象,如果没有宾语,那就是某物是什么或者某物怎么了。<br>这样,可以开始讨论一下这五个句子类型了。一个主语做了个事,附带还可能带有修饰成分。而做一件事,是具<br>有相对关系的,也就是,A对B做了什么,或者A独自做了什么,只有这两种可能了吧！</p><p>对于1,只有主语和动词,这就说明,该物独自干了个事情,没有作用对象,现在,想想我们生活中是不是有很多<br>一个物做事的时候? 比如,狗跑,叶落,风吹。<br>The dog runs,the leaves fall,the wind blows.<br>像上面的一类动词,自己就能把事情描述清楚,并不需要宾语,我们称之为不及物动词,及物就是需要接个宾语的<br>意思,不及物,就是我不需要宾语个人照样能玩得转,嘿嘿！所以像I kill, he eats, she loves 这种句子就<br>不对,因为呀,这种句子无法表达一个完整的事情,我杀,他吃,她爱,都不够妥帖,一看都知道,这些动词需要<br>有个作用的对象,也就是宾语,所以这种词就称为及物动词,但是要注意,及物动词和不及物动词有时候可以转换<br>,有的意思可能有些变化或者不变,比如run,作跑讲时,不及物,但是作为操作,运营时就是及物动词了,<br>His mother runs a company.他妈妈经营着一家公司,这时候的run就是及物动词了。所以背单词时候一定要看<br>清楚及物还是不及物,不要用错了,上面的句子,我们还是补全看着合适些:I killed him, he eats eggs. she loves me.</p><p>对于2,我想刚才的论述很完备了,不用再讲了.</p><p>对于3,这个需要多将一些,关于补语,我在相当长的一段时间内都是晕的.什么是补语呢？补语就是具有修饰性的<br>词语或者句子,干脆点讲,就是形容词。该句也就是某物怎么怎么样,这样一种描述性的句子,甚至不涉及到动词<br>有人马上就要问了,你句子里不是写的S + V + C吗？明明有动词,怎么不涉及动词呢？这样来看,似乎是对的<br>但是这样来理解就麻烦了,想这样的一类句子,</p><blockquote><p>She looks beautiful,<br>I am a handsome guy.<br>She appears unhappy.</p></blockquote><p>里面的动词不具有动作,我认为它们是假动词或者伪动词,他们的作用主要是连接主语和宾语做一种等价的描述<br>就是:她美,我帅,她不高兴,这里哪里有动作,完全没有嘛! 所以这种动词,语言学家又给他们名了个名:系动词<br>系就是联系,连缀的意思,这样的一类动词都可以翻译为’是’这个意思,而’是’是最没用的动词了.</p><blockquote><p>She looks beautiful = She is beautiful<br>She appears unhappy = She is unhappy</p></blockquote><p>你看是不是前后都通,一个意思嘛！所以呀,下次再给女友写情书,就不要写You looks beautiful 干脆写成<br>You are beautiful 来得实在,不美,你也不爱呀！要是她看起来不高兴,也别用appears了,当你都能感觉她<br>像生气了,那么多半错不了,得哄了,我以前就是不爱哄,完了,独身一人！<br>所以,言归正传,第三类句型就是什么是什么,至于像:I am a handsome guy.这样的句子,里面的guy不是形容<br>词,但是我们可以这样理解:我是一个具有男人性质的或者男子气息的小伙子,因为这样的句子肯定不只是要表达<br>一个陈述的意思,它还有一层暗含的意味在里面。所以,看美剧里有的人说:I am a man.时,他是说我是个男子<br>汉的意思,具有一种性质在里面。要是哪个女同学夸你：you are really a man.你真男人。你觉得她只想<br>说你是个男的？come on! 小子,是该你表现的时候了。对句子的分析足够敏感后,生活中什么人讲什么话<br>一下就懂了.说不定学好语言的套路后还能促进基因交流.</p><p>对于4,它就是第2和3两句复合的句型,S + V + O + C = S + V + (S + V + C)然后(S + V + C)又看成是O 或<br>C。这样S + V + O + C = S + V + (O/C)  还是基本句型嘛!这种句型如何理解呢？<br>可以先从后面来,O + C 就是宾语加补语,回到句型3,我们知道这是说什么是什么的意思。那么加上S + V<br>就是某物对于什么是什么有个动作,什么动作呢？比如,认为,考虑,使得等动作<br>所以I consider she funny, Tom made me crying.按照上面的定义O + C = S + V + C,O = S好理解,因为主语<br>宾语都可以是名词,补语相互对应,但是V是如何跑出来的呢？我们讲过,在S + V + C 中,V解释为’是’,所以<br>V 可以替换成具有是这个意思的动词。</p><blockquote><p>I consider she funny<br>S    V      O    C<br>I consider that she is funny<br>S    V           S   V   C</p></blockquote><p>这样,凡是这样的句子都可以加一个具有是这个意思的动词进去,然后加that 形成从句,表示cosider 了一件事<br>这件事就是She is funny.既然是一件事,就相当于名词,所以这个从句就是名词从句.</p><blockquote><p>I consider (that she is funny)<br>S    V           O </p></blockquote><p>所以回忆以前学习英语,是不是被要求背consider, made , deem 等等动词,造句时要有这一种规则?<br>这样的规则固然没错,可是谁又背得完呢?只要理解了,那么,那些动词是这样造句不是很简单吗？</p><blockquote><p>I insist you ugly<br>I believe the universe immense<br>I made the school teacher my wife </p></blockquote><p>然后你可以加一个’是’的动词到后面的成分来看句子通不通</p><blockquote><p>you are ugly<br>the niverse is immense<br>the school teacher is my wife</p></blockquote><p>是通的,那上面的三句就是 S + V + O + C的结构,这也是检查这种句子的方法:插入一个是,判断句子通顺</p><p>对于5.我想可以用一样的套路来理解,S + V + O + O = S + V + (S + V + O),同上面的分析如出一辙,</p><blockquote><p>I gave her a ring.<br>S   V   O   O<br>I call her honey<br>S   V   O   O</p></blockquote><p>注意这个和上面第四容易混淆,但是一旦我们利用插入是这个动词后</p><blockquote><p>she is a ring<br>she is honey</p></blockquote><p>句意不通,可见这是两个不同的宾语,没法儿划等,所以句型也就搞懂了</p><p>总结一下,判断句子的句型,就是这五种,而且最后两种特别好处理,第一种也一看就懂了,第三种找是这个<br>意思,找不出是这个意思就是第二种句型了<br>所以不要去背语法,要理解语法,解释语法,这就效率很高了,而且很有意思。一点儿都不枯燥。(Aug 14 2018)</p><h1 id="第一章-名词词组"><a href="#第一章-名词词组" class="headerlink" title="第一章 名词词组"></a>第一章 名词词组</h1><p>按照词类和语法穿插的模式,花点儿时间,将所有语法讲完是切实可行的.首先是名词或者说名词词组。<br>但是,光是讲名词是不行的,因为名词一定会用到句子中,而句子中的名词绝对是以名词词组的形式出现的,<br>所以需要讲名词词组的语法知识。我想,一种词汇成分,在句子中可以从三个方面来考虑:</p><p><strong>1.形式</strong></p><p><strong>2.位置</strong></p><p><strong>3.作用</strong></p><p>不论看什么句子,分析何种成分,要看该句子的形式：就是传统语法反复灌输的知识,二是:位置,这个很重要,<br>许多语法都是讲形式,对位置都是用:’规定就是如此’这样的说法来搪塞,至于作用嘛,谈得更少,<br>所以像下面的三句话,意思完全不一样,要是出现在听力中,绝对没什么人能作对</p><blockquote><p>a.He writes,as if he is a left-handed<br>(他写字的样子看起来就是个左撇子,本意:就是左撇子)<br>b.He writes,as if he was a left-handed<br>(他写字的样子看起来有点儿像是个左撇子,本意:有点儿像左撇子,但不敢肯定)<br>c.He writes,as if he were a left-handed<br>(他写字的样子,装得他是个左撇子一样,本意:装作左撇子,实际上不是左撇子)</p></blockquote><p>下面是听力对应的选项:</p><blockquote><p>A.he used to using left hand        听到a句时选择的答案<br>B.he may  like using left hand      听到b句时选择的答案<br>C.he used to using right hand       听到c句时选择的答案<br>D.he is capabal of using both hands 干扰项,给那些听清楚了,但犹豫的人准备的。 </p></blockquote><p>根据经验,A选项,极少数的人会选,即便他听到的是a句,因为他分别不出这里的用法,实际上,大部分能听<br>清楚的人听到任何一句都会选B,当然其他的大多数人是听不清楚就好办了,猜嘛!<br>这里c其实就是虚拟语气的用法,但是传统的句法,只讲了这个语气,但是从来不会把另外的ab两种用法给你讲<br>明白,因为他们认为语法知识讲到了,而且详细了。但是讲人写个类似a的句子时,大部分人就会写成c的版本,<br>然而这是错的,所以对语法的用法不熟悉,导致大部分人开始批判语法,进而讨厌语法。</p><p>现在开始正式进入语法知识点的学习,将语法知识连起来,而不是讲什么不规则动词表,抑或是什么有道词典时不时<br>搞的那种’还在用xxx表示xxx,你out了’这种知识最没用,最能麻痹人。<br>比如有次有道词典讲的:’还在用how are you,i am fine打招呼？’这样的噱头。<br>实际上，how are you是非常传统的,i am fine 也十分妥帖,打招呼用这个无论亲疏都可以，不知道有道是不是<br>招了几个考过了专八的会讲满口语法错误的英语的英语专业的毕业生.(Aug 27, 2018)</p><p>名词要看成词组，改词组由三部分组成，分为冠词，形容词，名词。三部分合在一起组成名词词组在句子中充当主语，宾语<br>等成分.<br>即：冠词 (副词) 形容词 名词 == 名称词组，在句子中充当语法成分，例如</p><blockquote><p>a bad girl<br>that tiny ball<br>a rather tired man</p></blockquote><p>可以看到，凡是一个名词在使用时，均是使用三部分构成，当然也可以少某些部分<br>the girl<br>those (暗指人，尤其在语境中)<br>apples<br>等等都是三部分省略的结果，凡是一个名词，一定要看成三部分的组合，这样才比较有把握。<br>    Oct 11, 2018 Shieber</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网站建立</title>
      <link href="/title/e6eb3c29/"/>
      <url>/title/e6eb3c29/</url>
      
        <content type="html"><![CDATA[<p>踩了各种坑，经过各种困难，终于把网站建立好了，利用hexo，只需要简单的几个指令。<br><a id="more"></a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo s</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>前端发展飞速，bootstrap，JQuery广泛使用，近来尤雨溪的Vue也开始火起来了。<br><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo</a>由台湾大神<a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">Tommy351</a>写就，在中国有着广泛的使用！据说他当年看哪个博客模板都觉得丑，遂自己写了一个，就是这个hexo.<br>以下是官方给的使用指南，十分简单。</p><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 网页 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 建站伊始 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
